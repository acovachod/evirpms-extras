diff --git a/Makefile.extra b/Makefile.extra
new file mode 100644
index 0000000..4aa6320
--- /dev/null
+++ b/Makefile.extra
@@ -0,0 +1,49 @@
+######################################################################-------------------------------------------------------------------------
+#
+# SQLite Foreign Data Wrapper for PostgreSQL
+#
+# Portions Copyright (c) 2018, TOSHIBA CORPORATION
+#
+# IDENTIFICATION
+# 		Makefile
+#
+##########################################################################
+
+MODULE_big = sqlite_fdw
+OBJS = connection.o option.o deparse.o sqlite_query.o sqlite_fdw.o
+
+EXTENSION = sqlite_fdw
+DATA = sqlite_fdw--1.0.sql
+
+REGRESS = sqlite_fdw type aggregate
+
+SQLITE_LIB = sqlite3
+
+UNAME = uname
+OS := $(shell $(UNAME))
+ifeq ($(OS), Darwin)
+DLSUFFIX = .dylib
+else
+DLSUFFIX = .so
+endif
+
+SHLIB_LINK := -lsqlite3
+
+ifdef USE_PGXS
+PG_CONFIG = pg_config
+PGXS := $(shell $(PG_CONFIG) --pgxs)
+include $(PGXS)
+ifndef MAJORVERSION
+MAJORVERSION := $(basename $(VERSION))
+endif
+ifeq (,$(findstring $(MAJORVERSION),9.6 10 11 12))
+$(error PostgreSQL  9.6, 10, 11 or 12 is required to compile this extension)
+endif
+
+else
+subdir = contrib/sqlite_fdw
+top_builddir = ../..
+include $(top_builddir)/src/Makefile.global
+include $(top_srcdir)/contrib/contrib-global.mk
+endif
+
diff --git a/README.md b/README.md
index be3c6b0..29b0f14 100644
--- a/README.md
+++ b/README.md
@@ -55,7 +55,7 @@ CREATE FOREIGN TABLE t1(a integer OPTIONS (key 'true'), b text) SERVER sqlite_se
 IMPORT FOREIGN SCHEMA public FROM SERVER sqlite_server INTO public;
 </pre>
 
-### Access foregin table
+### Access foreign table
 <pre>
 SELECT * FROM t1;
 </pre>
@@ -64,6 +64,8 @@ SELECT * FROM t1;
 - Support update to foreign table  
 - WHERE clauses are pushdowned  
 - Aggregate function are pushdowned
+- Order By is pushdowned.
+- Limit and Offset are pushdowned (*when all tables queried are fdw)
 - Transactions  
 
 ## Limitations
diff --git a/deparse.c b/deparse.c
index 5cc54e2..d7c049c 100644
--- a/deparse.c
+++ b/deparse.c
@@ -123,18 +123,18 @@ static void deparseFromExprForRel(StringInfo buf, PlannerInfo *root,
 								  bool use_alias, List **params_list);
 static void deparseFromExpr(List *quals, deparse_expr_cxt *context);
 static void deparseAggref(Aggref *node, deparse_expr_cxt *context);
+static void appendLimitClause(deparse_expr_cxt *context);
 static void appendConditions(List *exprs, deparse_expr_cxt *context);
 static void appendGroupByClause(List *tlist, deparse_expr_cxt *context);
 static void appendAggOrderBy(List *orderList, List *targetList,
 							 deparse_expr_cxt *context);
-static void appendOrderByClause(List *pathkeys, deparse_expr_cxt *context);
+static void appendOrderByClause(List *pathkeys, bool has_final_sort, deparse_expr_cxt *context);
 static void appendFunctionName(Oid funcid, deparse_expr_cxt *context);
 
 static Node *deparseSortGroupClause(Index ref, List *tlist, bool force_colno,
 									deparse_expr_cxt *context);
 static void deparseExplicitTargetList(List *tlist, List **retrieved_attrs,
 									  deparse_expr_cxt *context);
-static Expr *find_em_expr_for_rel(EquivalenceClass *ec, RelOptInfo *rel);
 static bool is_builtin(Oid objectId);
 
 /*
@@ -932,7 +932,8 @@ sqlite_build_tlist_to_deparse(RelOptInfo *foreignrel)
 void
 sqliteDeparseSelectStmtForRel(StringInfo buf, PlannerInfo *root, RelOptInfo *rel,
 							  List *tlist, List *remote_conds, List *pathkeys,
-							  bool is_subquery, List **retrieved_attrs,
+							  bool has_final_sort, bool has_limit, bool is_subquery,
+							  List **retrieved_attrs,
 							  List **params_list)
 {
 	deparse_expr_cxt context;
@@ -991,7 +992,11 @@ sqliteDeparseSelectStmtForRel(StringInfo buf, PlannerInfo *root, RelOptInfo *rel
 
 	/* Add ORDER BY clause if we found any useful pathkeys */
 	if (pathkeys)
-		appendOrderByClause(pathkeys, &context);
+		appendOrderByClause(pathkeys, has_final_sort, &context);
+
+	/* Add LIMIT clause if necessary */
+	if (has_limit)
+		appendLimitClause(&context);
 
 }
 
@@ -2405,42 +2410,13 @@ appendAggOrderBy(List *orderList, List *targetList, deparse_expr_cxt *context)
 	}
 }
 
-/*
- * Find an equivalence class member expression, all of whose Vars, come from
- * the indicated relation.
- */
-static Expr *
-find_em_expr_for_rel(EquivalenceClass *ec, RelOptInfo *rel)
-{
-	ListCell   *lc_em;
-
-	foreach(lc_em, ec->ec_members)
-	{
-		EquivalenceMember *em = lfirst(lc_em);
-
-		if (bms_is_subset(em->em_relids, rel->relids))
-		{
-			/*
-			 * If there is more than one equivalence member whose Vars are
-			 * taken entirely from this relation, we'll be content to choose
-			 * any one of those.
-			 */
-			return em->em_expr;
-		}
-	}
-
-	/* We didn't find any suitable equivalence class expression */
-	return NULL;
-}
-
-
 /*
  * Deparse ORDER BY clause according to the given pathkeys for given base
  * relation. From given pathkeys expressions belonging entirely to the given
  * base relation are obtained and deparsed.
  */
 static void
-appendOrderByClause(List *pathkeys, deparse_expr_cxt *context)
+appendOrderByClause(List *pathkeys, bool has_final_sort, deparse_expr_cxt *context)
 {
 	ListCell   *lcell;
 	int			nestlevel;
@@ -2457,7 +2433,20 @@ appendOrderByClause(List *pathkeys, deparse_expr_cxt *context)
 		PathKey    *pathkey = lfirst(lcell);
 		Expr	   *em_expr;
 
-		em_expr = find_em_expr_for_rel(pathkey->pk_eclass, baserel);
+		if (has_final_sort)
+		{
+			/*
+			 * By construction, context->foreignrel is the input relation to
+			 * the final sort.
+			 */
+			em_expr = find_em_expr_for_input_target(context->root,
+													pathkey->pk_eclass,
+													context->foreignrel->reltarget,
+													baserel);
+		}
+		else
+			em_expr = find_em_expr_for_rel(pathkey->pk_eclass, baserel);
+
 		Assert(em_expr != NULL);
 
 		appendStringInfoString(buf, delim);
@@ -2467,13 +2456,65 @@ appendOrderByClause(List *pathkeys, deparse_expr_cxt *context)
 		else
 			appendStringInfoString(buf, " DESC");
 
-		if (pathkey->pk_nulls_first)
-			elog(ERROR, "NULLS FIRST not supported");
+		// XXX: In SQLITE3 Release v3.30.0 (2019-10-04) NULLS FIRST/LAST is supported, but not in prior versions
+		// More info: https://www.sqlite.org/changes.html https://www.sqlite.org/lang_select.html#orderby
+		int sqliteVersion = sqlite3_libversion_number();
+
+		if (sqliteVersion >= 3030000)
+		{
+			if (pathkey->pk_nulls_first)
+				appendStringInfoString(buf, " NULLS FIRST");
+			else
+				appendStringInfoString(buf, " NULLS LAST");
+		}
+		else
+		{
+			// If we need a different behaviour than SQLite default...we show warning message because NULLS FIRST/LAST is not implemented in this SQLite version.
+			if (!pathkey->pk_nulls_first && pathkey->pk_strategy == BTLessStrategyNumber)
+				elog(WARNING, "Current Sqlite Version (%d) does not support NULLS LAST for ORDER BY ASC, degraded emitted query to ORDER BY ASC NULLS FIRST (default sqlite behaviour).", sqliteVersion);
+			else if (pathkey->pk_nulls_first && pathkey->pk_strategy != BTLessStrategyNumber)
+				elog(WARNING, "Current Sqlite Version (%d) does not support NULLS FIRST for ORDER BY DESC, degraded emitted query to ORDER BY DESC NULLS LAST (default sqlite behaviour).", sqliteVersion);
+		}
+
 		delim = ", ";
 	}
 	sqlite_reset_transmission_modes(nestlevel);
 }
 
+/*
+ * Deparse LIMIT/OFFSET clause.
+ */
+static void
+appendLimitClause(deparse_expr_cxt *context)
+{
+	PlannerInfo *root = context->root;
+	StringInfo	buf = context->buf;
+	int			nestlevel;
+
+	/* Make sure any constants in the exprs are printed portably */
+	nestlevel = sqlite_set_transmission_modes();
+
+	if (root->parse->limitCount)
+	{
+		appendStringInfoString(buf, " LIMIT ");
+		deparseExpr((Expr *) root->parse->limitCount, context);
+	}
+	else
+	{
+		/* We add this LIMIT -1 because OFFSET by itself its not implemented/allowed in SQLite.
+		You need to provide LIMIT *always* when using OFFSET */
+		appendStringInfoString(buf, " LIMIT -1");
+	}
+
+	if (root->parse->limitOffset)
+	{
+		appendStringInfoString(buf, " OFFSET ");
+		deparseExpr((Expr *) root->parse->limitOffset, context);
+	}
+
+	sqlite_reset_transmission_modes(nestlevel);
+}
+
 /*
  * appendFunctionName
  *		Deparses function name from given function oid.
diff --git a/expected/aggregate.out b/expected/aggregate.out
index 89143f3..8872eec 100644
--- a/expected/aggregate.out
+++ b/expected/aggregate.out
@@ -1,3 +1,9 @@
+--SET log_min_messages  TO DEBUG1;
+--SET client_min_messages  TO DEBUG1;
+CREATE EXTENSION sqlite_fdw;
+CREATE SERVER sqlite_svr FOREIGN DATA WRAPPER sqlite_fdw
+OPTIONS (database '/tmp/sqlitefdw_test.db');
+CREATE FOREIGN TABLE multiprimary(a int, b int OPTIONS (key 'true'), c int OPTIONS(key 'true')) SERVER sqlite_svr;
 -- test for aggregate pushdown
 explain (costs off, verbose) select count(distinct a) from multiprimary;
                              QUERY PLAN                              
@@ -16,15 +22,12 @@ explain (costs off, verbose) select sum(b),max(b), min(b), avg(b) from multiprim
 (3 rows)
 
 explain (costs off, verbose) select sum(b+5)+2 from multiprimary group by b/2 order by b/2;
-                                            QUERY PLAN                                            
---------------------------------------------------------------------------------------------------
- Sort
-   Output: ((sum((b + 5)) + '2'::numeric)), ((b / 2))
-   Sort Key: ((multiprimary.b / 2))
-   ->  Foreign Scan
-         Output: ((sum((b + 5)) + '2'::numeric)), ((b / 2))
-         SQLite query: SELECT (sum((`b` + 5)) + 2), (`b` / 2) FROM main."multiprimary" GROUP BY 2
-(6 rows)
+                                                          QUERY PLAN                                                          
+------------------------------------------------------------------------------------------------------------------------------
+ Foreign Scan
+   Output: ((sum((b + 5)) + 2)), ((b / 2))
+   SQLite query: SELECT (sum((`b` + 5)) + 2), (`b` / 2) FROM main."multiprimary" GROUP BY 2 ORDER BY (`b` / 2) ASC NULLS LAST
+(3 rows)
 
 explain (costs off, verbose) select sum(a) from multiprimary group by b having sum(a) > 0;
                                             QUERY PLAN                                            
@@ -35,15 +38,15 @@ explain (costs off, verbose) select sum(a) from multiprimary group by b having s
 (3 rows)
 
 explain (costs off, verbose) select sum(a) from multiprimary group by b having avg(a^2) > 0 and sum(a) > 0;
-                                                                    QUERY PLAN                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------
- HashAggregate
+                                                              QUERY PLAN                                                               
+---------------------------------------------------------------------------------------------------------------------------------------
+ GroupAggregate
    Output: sum(a), b
    Group Key: multiprimary.b
-   Filter: ((avg(((multiprimary.a)::double precision ^ '2'::double precision)) > '0'::double precision) AND (sum(multiprimary.a) > '0'::numeric))
+   Filter: ((avg(((multiprimary.a)::double precision ^ '2'::double precision)) > '0'::double precision) AND (sum(multiprimary.a) > 0))
    ->  Foreign Scan on public.multiprimary
          Output: a, b, c
-         SQLite query: SELECT `a`, `b` FROM main."multiprimary"
+         SQLite query: SELECT `a`, `b` FROM main."multiprimary" ORDER BY `b` ASC NULLS LAST
 (7 rows)
 
 -- stddev and variance are not pushed down
@@ -58,14 +61,17 @@ explain (costs off, verbose) select stddev(a) from multiprimary;
 (5 rows)
 
 explain (costs off, verbose) select sum(a) from multiprimary group by b having variance(a) > 0;
-                           QUERY PLAN                           
-----------------------------------------------------------------
- HashAggregate
+                                         QUERY PLAN                                         
+--------------------------------------------------------------------------------------------
+ GroupAggregate
    Output: sum(a), b
    Group Key: multiprimary.b
    Filter: (variance(multiprimary.a) > '0'::numeric)
    ->  Foreign Scan on public.multiprimary
          Output: a, b, c
-         SQLite query: SELECT `a`, `b` FROM main."multiprimary"
+         SQLite query: SELECT `a`, `b` FROM main."multiprimary" ORDER BY `b` ASC NULLS LAST
 (7 rows)
 
+DROP FOREIGN TABLE multiprimary;
+DROP SERVER sqlite_svr;
+DROP EXTENSION sqlite_fdw CASCADE;
diff --git a/expected/extra/aggregates.out b/expected/extra/aggregates.out
index 3a249af..911b0e4 100644
--- a/expected/extra/aggregates.out
+++ b/expected/extra/aggregates.out
@@ -71,17 +71,18 @@ SELECT avg(a) AS avg_32 FROM aggtest WHERE a < 100;
 (1 row)
 
 -- In 7.1, avg(float4) is computed using float8 arithmetic.
--- Round the result to 3 digits to avoid platform-specific results.
+-- Round the result to limited digits to avoid platform-specific results.
 SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
  avg_107_943 
 -------------
      107.943
 (1 row)
 
-SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT avg(gpa)::numeric(10,3) AS avg_3_4 FROM ONLY student;
  avg_3_4 
 ---------
-     3.4
+   3.400
 (1 row)
 
 SELECT sum(four) AS sum_1500 FROM onek;
@@ -96,16 +97,18 @@ SELECT sum(a) AS sum_198 FROM aggtest;
      198
 (1 row)
 
-SELECT sum(b) AS avg_431_773 FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT sum(b)::numeric(10,3) AS avg_431_773 FROM aggtest;
  avg_431_773 
 -------------
      431.773
 (1 row)
 
-SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT sum(gpa)::numeric(10,3) AS avg_6_8 FROM ONLY student;
  avg_6_8 
 ---------
-     6.8
+   6.800
 (1 row)
 
 SELECT max(four) AS max_3 FROM onek;
@@ -132,25 +135,29 @@ SELECT max(student.gpa) AS max_3_7 FROM student;
      3.7
 (1 row)
 
-SELECT stddev_pop(b) FROM aggtest;
-   stddev_pop    
------------------
- 131.10703231895
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT stddev_pop(b)::numeric(20,10) FROM aggtest;
+   stddev_pop   
+----------------
+ 131.1070323190
 (1 row)
 
-SELECT stddev_samp(b) FROM aggtest;
-   stddev_samp    
-------------------
- 151.389360803998
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT stddev_samp(b)::numeric(20,10) FROM aggtest;
+  stddev_samp   
+----------------
+ 151.3893608040
 (1 row)
 
-SELECT var_pop(b) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT var_pop(b)::numeric(20,10) FROM aggtest;
      var_pop      
 ------------------
  17189.0539234823
 (1 row)
 
-SELECT var_samp(b) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT var_samp(b)::numeric(20,10) FROM aggtest;
      var_samp     
 ------------------
  22918.7385646431
@@ -193,46 +200,53 @@ SELECT regr_sxx(b, a) FROM aggtest;
      5099
 (1 row)
 
-SELECT regr_syy(b, a) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_syy(b, a)::numeric(20,10) FROM aggtest;
      regr_syy     
 ------------------
  68756.2156939293
 (1 row)
 
-SELECT regr_sxy(b, a) FROM aggtest;
-     regr_sxy     
-------------------
- 2614.51582155004
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_sxy(b, a)::numeric(20,10) FROM aggtest;
+    regr_sxy     
+-----------------
+ 2614.5158215500
 (1 row)
 
-SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
- regr_avgx |    regr_avgy     
------------+------------------
-      49.5 | 107.943152273074
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_avgx(b, a), regr_avgy(b, a)::numeric(20,10) FROM aggtest;
+ regr_avgx |   regr_avgy    
+-----------+----------------
+      49.5 | 107.9431522731
 (1 row)
 
-SELECT regr_r2(b, a) FROM aggtest;
-      regr_r2       
---------------------
- 0.0194977982031803
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_r2(b, a)::numeric(20,10) FROM aggtest;
+   regr_r2    
+--------------
+ 0.0194977982
 (1 row)
 
-SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
-    regr_slope     |  regr_intercept  
--------------------+------------------
- 0.512750700441271 | 82.5619926012309
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_slope(b, a)::numeric(20,10), regr_intercept(b, a)::numeric(20,10) FROM aggtest;
+  regr_slope  | regr_intercept 
+--------------+----------------
+ 0.5127507004 |  82.5619926012
 (1 row)
 
-SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
-    covar_pop    |    covar_samp    
------------------+------------------
- 653.62895538751 | 871.505273850014
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT covar_pop(b, a)::numeric(20,10), covar_samp(b, a)::numeric(20,10) FROM aggtest;
+   covar_pop    |   covar_samp   
+----------------+----------------
+ 653.6289553875 | 871.5052738500
 (1 row)
 
-SELECT corr(b, a) FROM aggtest;
-       corr        
--------------------
- 0.139634516517873
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT corr(b, a)::numeric(20,10) FROM aggtest;
+     corr     
+--------------
+ 0.1396345165
 (1 row)
 
 SELECT count(four) AS cnt_1000 FROM onek;
@@ -620,12 +634,10 @@ select distinct max(unique2) from tenk1;
 
 explain (costs off)
   select max(unique2) from tenk1 order by 1;
-         QUERY PLAN         
-----------------------------
- Sort
-   Sort Key: (max(unique2))
-   ->  Foreign Scan
-(3 rows)
+  QUERY PLAN  
+--------------
+ Foreign Scan
+(1 row)
 
 select max(unique2) from tenk1 order by 1;
  max  
@@ -635,12 +647,10 @@ select max(unique2) from tenk1 order by 1;
 
 explain (costs off)
   select max(unique2) from tenk1 order by max(unique2);
-         QUERY PLAN         
-----------------------------
- Sort
-   Sort Key: (max(unique2))
-   ->  Foreign Scan
-(3 rows)
+  QUERY PLAN  
+--------------
+ Foreign Scan
+(1 row)
 
 select max(unique2) from tenk1 order by max(unique2);
  max  
@@ -650,12 +660,10 @@ select max(unique2) from tenk1 order by max(unique2);
 
 explain (costs off)
   select max(unique2) from tenk1 order by max(unique2)+1;
-            QUERY PLAN            
-----------------------------------
- Sort
-   Sort Key: ((max(unique2) + 1))
-   ->  Foreign Scan
-(3 rows)
+  QUERY PLAN  
+--------------
+ Foreign Scan
+(1 row)
 
 select max(unique2) from tenk1 order by max(unique2)+1;
  max  
@@ -696,7 +704,7 @@ select max(100) from tenk1;
 (1 row)
 
 -- try it on an inheritance tree
-create foreign table minmaxtest(f1 int) server sqlite_svr;;
+create foreign table minmaxtest(f1 int) server sqlite_svr;
 create table minmaxtest1() inherits (minmaxtest);
 create table minmaxtest2() inherits (minmaxtest);
 create table minmaxtest3() inherits (minmaxtest);
@@ -709,15 +717,30 @@ insert into minmaxtest2 values(15), (16);
 insert into minmaxtest3 values(17), (18);
 explain (costs off)
   select min(f1), max(f1) from minmaxtest;
-               QUERY PLAN               
-----------------------------------------
- Aggregate
-   ->  Append
-         ->  Foreign Scan on minmaxtest
-         ->  Seq Scan on minmaxtest1
-         ->  Seq Scan on minmaxtest2
-         ->  Seq Scan on minmaxtest3
-(6 rows)
+                                          QUERY PLAN                                          
+----------------------------------------------------------------------------------------------
+ Result
+   InitPlan 1 (returns $0)
+     ->  Limit
+           ->  Merge Append
+                 Sort Key: minmaxtest.f1
+                 ->  Foreign Scan on minmaxtest
+                 ->  Index Only Scan using minmaxtest1i on minmaxtest1
+                       Index Cond: (f1 IS NOT NULL)
+                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2
+                       Index Cond: (f1 IS NOT NULL)
+                 ->  Index Only Scan using minmaxtest3i on minmaxtest3
+   InitPlan 2 (returns $1)
+     ->  Limit
+           ->  Merge Append
+                 Sort Key: minmaxtest_1.f1 DESC
+                 ->  Foreign Scan on minmaxtest minmaxtest_1
+                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest1_1
+                       Index Cond: (f1 IS NOT NULL)
+                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest2_1
+                       Index Cond: (f1 IS NOT NULL)
+                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest3_1
+(21 rows)
 
 select min(f1), max(f1) from minmaxtest;
  min | max 
@@ -728,18 +751,33 @@ select min(f1), max(f1) from minmaxtest;
 -- DISTINCT doesn't do anything useful here, but it shouldn't fail
 explain (costs off)
   select distinct min(f1), max(f1) from minmaxtest;
-                          QUERY PLAN                          
---------------------------------------------------------------
+                                          QUERY PLAN                                          
+----------------------------------------------------------------------------------------------
  Unique
+   InitPlan 1 (returns $0)
+     ->  Limit
+           ->  Merge Append
+                 Sort Key: minmaxtest.f1
+                 ->  Foreign Scan on minmaxtest
+                 ->  Index Only Scan using minmaxtest1i on minmaxtest1
+                       Index Cond: (f1 IS NOT NULL)
+                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2
+                       Index Cond: (f1 IS NOT NULL)
+                 ->  Index Only Scan using minmaxtest3i on minmaxtest3
+   InitPlan 2 (returns $1)
+     ->  Limit
+           ->  Merge Append
+                 Sort Key: minmaxtest_1.f1 DESC
+                 ->  Foreign Scan on minmaxtest minmaxtest_1
+                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest1_1
+                       Index Cond: (f1 IS NOT NULL)
+                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest2_1
+                       Index Cond: (f1 IS NOT NULL)
+                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest3_1
    ->  Sort
-         Sort Key: (min(minmaxtest.f1)), (max(minmaxtest.f1))
-         ->  Aggregate
-               ->  Append
-                     ->  Foreign Scan on minmaxtest
-                     ->  Seq Scan on minmaxtest1
-                     ->  Seq Scan on minmaxtest2
-                     ->  Seq Scan on minmaxtest3
-(9 rows)
+         Sort Key: ($0), ($1)
+         ->  Result
+(24 rows)
 
 select distinct min(f1), max(f1) from minmaxtest;
  min | max 
@@ -1305,16 +1343,18 @@ ERROR:  WITHIN GROUP is required for ordered-set aggregate percentile_cont
 LINE 1: select f1, percentile_cont(f1,f1)  
                    ^
 rollback;
-select percentile_cont(0.5) within group (order by b) from aggtest;
- percentile_cont  
-------------------
- 53.4485001564026
+-- Round the result to limited digits to avoid platform-specific results.
+select (percentile_cont(0.5) within group (order by b))::numeric(20,10) from aggtest;
+ percentile_cont 
+-----------------
+   53.4485001564
 (1 row)
 
-select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
- percentile_cont  |   sum   
-------------------+---------
- 53.4485001564026 | 431.773
+-- Round the result to limited digits to avoid platform-specific results.
+select (percentile_cont(0.5) within group (order by b))::numeric(20,10), sum(b)::numeric(10,3) from aggtest;
+ percentile_cont |   sum   
+-----------------+---------
+   53.4485001564 | 431.773
 (1 row)
 
 select percentile_cont(0.5) within group (order by thousand) from tenk1;
@@ -1344,10 +1384,11 @@ select cume_dist(3) within group (order by f1) from INT4_TBL;
      0.875
 (1 row)
 
-select percent_rank(3) within group (order by f1) from INT4_TBL;
-   percent_rank    
--------------------
- 0.571428571428571
+-- Round the result to limited digits to avoid platform-specific results.
+select (percent_rank(3) within group (order by f1))::numeric(20,10) from INT4_TBL;
+ percent_rank 
+--------------
+ 0.5714285714
 (1 row)
 
 select dense_rank(3) within group (order by f1) from INT4_TBL;
diff --git a/expected/extra/float4.out b/expected/extra/float4.out
index 04b57be..d62eb82 100644
--- a/expected/extra/float4.out
+++ b/expected/extra/float4.out
@@ -12,19 +12,19 @@ INSERT INTO FLOAT4_TBL(f1) VALUES ('1.2345678901234e+20');
 INSERT INTO FLOAT4_TBL(f1) VALUES ('1.2345678901234e-20');
 -- test for over and under flow
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e70');
-ERROR:  value out of range: overflow
+ERROR:  "10e70" is out of range for type real
 LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('10e70');
                                            ^
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70');
-ERROR:  value out of range: overflow
+ERROR:  "-10e70" is out of range for type real
 LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e70');
                                            ^
 INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70');
-ERROR:  value out of range: underflow
+ERROR:  "10e-70" is out of range for type real
 LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('10e-70');
                                            ^
 INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70');
-ERROR:  value out of range: underflow
+ERROR:  "-10e-70" is out of range for type real
 LINE 1: INSERT INTO FLOAT4_TBL(f1) VALUES ('-10e-70');
                                            ^
 -- bad input
@@ -109,104 +109,104 @@ SELECT * FROM FLOAT4_TBL;
 
 ROLLBACK;
 SELECT '' AS five, * FROM FLOAT4_TBL;
- five |     f1      
-------+-------------
-      |           0
-      |      1004.3
-      |      -34.84
-      | 1.23457e+20
-      | 1.23457e-20
+ five |      f1       
+------+---------------
+      |             0
+      |        1004.3
+      |        -34.84
+      | 1.2345679e+20
+      | 1.2345679e-20
 (5 rows)
 
 SELECT '' AS four, f.* FROM FLOAT4_TBL f WHERE '1004.3' >= f.f1;
- four |     f1      
-------+-------------
-      |           0
-      |      1004.3
-      |      -34.84
-      | 1.23457e-20
+ four |      f1       
+------+---------------
+      |             0
+      |        1004.3
+      |        -34.84
+      | 1.2345679e-20
 (4 rows)
 
 SELECT '' AS four, f.* FROM FLOAT4_TBL f WHERE  f.f1 <= '1004.3';
- four |     f1      
-------+-------------
-      |           0
-      |      1004.3
-      |      -34.84
-      | 1.23457e-20
+ four |      f1       
+------+---------------
+      |             0
+      |        1004.3
+      |        -34.84
+      | 1.2345679e-20
 (4 rows)
 
 SELECT '' AS three, f.f1, f.f1 * '-10' AS x FROM FLOAT4_TBL f
    WHERE f.f1 > '0.0';
- three |     f1      |      x       
--------+-------------+--------------
-       |      1004.3 |       -10043
-       | 1.23457e+20 | -1.23457e+21
-       | 1.23457e-20 | -1.23457e-19
+ three |      f1       |       x        
+-------+---------------+----------------
+       |        1004.3 |         -10043
+       | 1.2345679e+20 | -1.2345678e+21
+       | 1.2345679e-20 | -1.2345678e-19
 (3 rows)
 
 SELECT '' AS three, f.f1, f.f1 + '-10' AS x FROM FLOAT4_TBL f
    WHERE f.f1 > '0.0';
- three |     f1      |      x      
--------+-------------+-------------
-       |      1004.3 |       994.3
-       | 1.23457e+20 | 1.23457e+20
-       | 1.23457e-20 |         -10
+ three |      f1       |       x       
+-------+---------------+---------------
+       |        1004.3 |         994.3
+       | 1.2345679e+20 | 1.2345679e+20
+       | 1.2345679e-20 |           -10
 (3 rows)
 
 SELECT '' AS three, f.f1, f.f1 / '-10' AS x FROM FLOAT4_TBL f
    WHERE f.f1 > '0.0';
- three |     f1      |      x       
--------+-------------+--------------
-       |      1004.3 |      -100.43
-       | 1.23457e+20 | -1.23457e+19
-       | 1.23457e-20 | -1.23457e-21
+ three |      f1       |       x        
+-------+---------------+----------------
+       |        1004.3 |        -100.43
+       | 1.2345679e+20 | -1.2345679e+19
+       | 1.2345679e-20 | -1.2345679e-21
 (3 rows)
 
 SELECT '' AS three, f.f1, f.f1 - '-10' AS x FROM FLOAT4_TBL f
    WHERE f.f1 > '0.0';
- three |     f1      |      x      
--------+-------------+-------------
-       |      1004.3 |      1014.3
-       | 1.23457e+20 | 1.23457e+20
-       | 1.23457e-20 |          10
+ three |      f1       |       x       
+-------+---------------+---------------
+       |        1004.3 |        1014.3
+       | 1.2345679e+20 | 1.2345679e+20
+       | 1.2345679e-20 |            10
 (3 rows)
 
 -- test divide by zero
 SELECT '' AS bad, f.f1 / '0.0' from FLOAT4_TBL f;
 ERROR:  division by zero
 SELECT '' AS five, * FROM FLOAT4_TBL;
- five |     f1      
-------+-------------
-      |           0
-      |      1004.3
-      |      -34.84
-      | 1.23457e+20
-      | 1.23457e-20
+ five |      f1       
+------+---------------
+      |             0
+      |        1004.3
+      |        -34.84
+      | 1.2345679e+20
+      | 1.2345679e-20
 (5 rows)
 
 -- test the unary float4abs operator
 SELECT '' AS five, f.f1, @f.f1 AS abs_f1 FROM FLOAT4_TBL f;
- five |     f1      |   abs_f1    
-------+-------------+-------------
-      |           0 |           0
-      |      1004.3 |      1004.3
-      |      -34.84 |       34.84
-      | 1.23457e+20 | 1.23457e+20
-      | 1.23457e-20 | 1.23457e-20
+ five |      f1       |    abs_f1     
+------+---------------+---------------
+      |             0 |             0
+      |        1004.3 |        1004.3
+      |        -34.84 |         34.84
+      | 1.2345679e+20 | 1.2345679e+20
+      | 1.2345679e-20 | 1.2345679e-20
 (5 rows)
 
 UPDATE FLOAT4_TBL
    SET f1 = FLOAT4_TBL.f1 * '-1'
    WHERE FLOAT4_TBL.f1 > '0.0';
 SELECT '' AS five, * FROM FLOAT4_TBL;
- five |      f1      
-------+--------------
-      |            0
-      |      -1004.3
-      |       -34.84
-      | -1.23457e+20
-      | -1.23457e-20
+ five |       f1       
+------+----------------
+      |              0
+      |        -1004.3
+      |         -34.84
+      | -1.2345679e+20
+      | -1.2345679e-20
 (5 rows)
 
 DROP FOREIGN TABLE FLOAT4_TBL;
diff --git a/expected/extra/float8.out b/expected/extra/float8.out
index 52752f3..72e89bf 100644
--- a/expected/extra/float8.out
+++ b/expected/extra/float8.out
@@ -192,7 +192,7 @@ SELECT '' AS three, f.f1, f.f1 / '-10' AS x
    WHERE f.f1 > '0.0';
  three |          f1          |           x           
 -------+----------------------+-----------------------
-       |               1004.3 |               -100.43
+       |               1004.3 |   -100.42999999999999
        | 1.2345678901234e+200 | -1.2345678901234e+199
        | 1.2345678901234e-200 | -1.2345678901234e-201
 (3 rows)
@@ -209,9 +209,9 @@ SELECT '' AS three, f.f1, f.f1 - '-10' AS x
 
 SELECT '' AS one, f.f1 ^ '2.0' AS square_f1
    FROM FLOAT8_TBL f where f.f1 = '1004.3';
- one | square_f1  
------+------------
-     | 1008618.49
+ one |     square_f1      
+-----+--------------------
+     | 1008618.4899999999
 (1 row)
 
 -- absolute value
@@ -309,11 +309,11 @@ ROLLBACK;
 SELECT '' AS three, f.f1, |/f.f1 AS sqrt_f1
    FROM FLOAT8_TBL f
    WHERE f.f1 > '0.0';
- three |          f1          |        sqrt_f1        
--------+----------------------+-----------------------
-       |               1004.3 |      31.6906926399535
-       | 1.2345678901234e+200 | 1.11111110611109e+100
-       | 1.2345678901234e-200 | 1.11111110611109e-100
+ three |          f1          |         sqrt_f1         
+-------+----------------------+-------------------------
+       |               1004.3 |      31.690692639953454
+       | 1.2345678901234e+200 | 1.1111111061110856e+100
+       | 1.2345678901234e-200 | 1.1111111061110855e-100
 (3 rows)
 
 -- power
@@ -343,11 +343,11 @@ ROLLBACK;
 SELECT '' AS three, f.f1, exp(ln(f.f1)) AS exp_ln_f1
    FROM FLOAT8_TBL f
    WHERE f.f1 > '0.0';
- three |          f1          |       exp_ln_f1       
--------+----------------------+-----------------------
-       |               1004.3 |                1004.3
-       | 1.2345678901234e+200 | 1.23456789012338e+200
-       | 1.2345678901234e-200 | 1.23456789012339e-200
+ three |          f1          |        exp_ln_f1        
+-------+----------------------+-------------------------
+       |               1004.3 |      1004.3000000000004
+       | 1.2345678901234e+200 |  1.234567890123379e+200
+       | 1.2345678901234e-200 | 1.2345678901233948e-200
 (3 rows)
 
 -- cube root
@@ -355,20 +355,20 @@ BEGIN;
 DELETE FROM FLOAT8_TBL;
 INSERT INTO FLOAT8_TBL VALUES (||/ float8 '27');
 SELECT * FROM FLOAT8_TBL;
- f1 
-----
-  3
+         f1         
+--------------------
+ 3.0000000000000004
 (1 row)
 
 ROLLBACK;
 SELECT '' AS five, f.f1, ||/f.f1 AS cbrt_f1 FROM FLOAT8_TBL f;
- five |          f1          |       cbrt_f1        
-------+----------------------+----------------------
-      |                    0 |                    0
-      |               1004.3 |      10.014312837827
-      |               -34.84 |    -3.26607421344208
-      | 1.2345678901234e+200 | 4.97933859234765e+66
-      | 1.2345678901234e-200 |  2.3112042409018e-67
+ five |          f1          |        cbrt_f1         
+------+----------------------+------------------------
+      |                    0 |                      0
+      |               1004.3 |     10.014312837827033
+      |               -34.84 |    -3.2660742134420806
+      | 1.2345678901234e+200 |  4.979338592347648e+66
+      | 1.2345678901234e-200 | 2.3112042409018007e-67
 (5 rows)
 
 SELECT '' AS five, * FROM FLOAT8_TBL;
diff --git a/expected/extra/insert.out b/expected/extra/insert.out
index 2b59861..c556d01 100644
--- a/expected/extra/insert.out
+++ b/expected/extra/insert.out
@@ -6,7 +6,7 @@ CREATE SERVER sqlite_svr FOREIGN DATA WRAPPER sqlite_fdw
 OPTIONS (database '/tmp/sqlitefdw_test_core.db');
 CREATE FOREIGN TABLE inserttest01 (col1 int4, col2 int4 NOT NULL, col3 text default 'testing') SERVER sqlite_svr;
 insert into inserttest01 (col1, col2, col3) values (DEFAULT, DEFAULT, DEFAULT);
-ERROR:  failed to execute remote SQL: rc=19 inserttest01.col2 may not be NULL 
+ERROR:  failed to execute remote SQL: rc=19 NOT NULL constraint failed: inserttest01.col2 
    sql=INSERT INTO main."inserttest01"(`col1`, `col2`, `col3`) VALUES (?, ?, ?)
 insert into inserttest01 (col2, col3) values (3, DEFAULT);
 insert into inserttest01 (col1, col2, col3) values (DEFAULT, 5, DEFAULT);
diff --git a/expected/extra/int4.out b/expected/extra/int4.out
index 28a74d7..3f506ba 100644
--- a/expected/extra/int4.out
+++ b/expected/extra/int4.out
@@ -9,7 +9,7 @@ INSERT INTO INT4_TBL(f1) VALUES ('   0  ');
 INSERT INTO INT4_TBL(f1) VALUES ('123456     ');
 INSERT INTO INT4_TBL(f1) VALUES ('    -123456');
 INSERT INTO INT4_TBL(f1) VALUES ('34.5');
-ERROR:  invalid input syntax for integer: "34.5"
+ERROR:  invalid input syntax for type integer: "34.5"
 LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('34.5');
                                          ^
 -- largest and smallest values
@@ -21,27 +21,27 @@ ERROR:  value "1000000000000" is out of range for type integer
 LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('1000000000000');
                                          ^
 INSERT INTO INT4_TBL(f1) VALUES ('asdf');
-ERROR:  invalid input syntax for integer: "asdf"
+ERROR:  invalid input syntax for type integer: "asdf"
 LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('asdf');
                                          ^
 INSERT INTO INT4_TBL(f1) VALUES ('     ');
-ERROR:  invalid input syntax for integer: "     "
+ERROR:  invalid input syntax for type integer: "     "
 LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('     ');
                                          ^
 INSERT INTO INT4_TBL(f1) VALUES ('   asdf   ');
-ERROR:  invalid input syntax for integer: "   asdf   "
+ERROR:  invalid input syntax for type integer: "   asdf   "
 LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('   asdf   ');
                                          ^
 INSERT INTO INT4_TBL(f1) VALUES ('- 1234');
-ERROR:  invalid input syntax for integer: "- 1234"
+ERROR:  invalid input syntax for type integer: "- 1234"
 LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('- 1234');
                                          ^
 INSERT INTO INT4_TBL(f1) VALUES ('123       5');
-ERROR:  invalid input syntax for integer: "123       5"
+ERROR:  invalid input syntax for type integer: "123       5"
 LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('123       5');
                                          ^
 INSERT INTO INT4_TBL(f1) VALUES ('');
-ERROR:  invalid input syntax for integer: ""
+ERROR:  invalid input syntax for type integer: ""
 LINE 1: INSERT INTO INT4_TBL(f1) VALUES ('');
                                          ^
 SELECT '' AS five, * FROM INT4_TBL;
diff --git a/expected/extra/int8.out b/expected/extra/int8.out
index e02f429..c53b603 100644
--- a/expected/extra/int8.out
+++ b/expected/extra/int8.out
@@ -11,16 +11,16 @@ CREATE FOREIGN TABLE INT8_TBL(
 ) SERVER sqlite_svr;
 INSERT INTO INT8_TBL VALUES('  123   ','  456');
 INSERT INTO INT8_TBL VALUES('123   ','4567890123456789');
+INSERT INTO INT8_TBL VALUES('+4567890123456789','-4567890123456789');
 INSERT INTO INT8_TBL VALUES('4567890123456789','123');
 INSERT INTO INT8_TBL VALUES(+4567890123456789,'4567890123456789');
-INSERT INTO INT8_TBL VALUES('+4567890123456789','-4567890123456789');
 -- bad inputs
 INSERT INTO INT8_TBL(q1) VALUES ('      ');
-ERROR:  invalid input syntax for integer: "      "
+ERROR:  invalid input syntax for type bigint: "      "
 LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('      ');
                                          ^
 INSERT INTO INT8_TBL(q1) VALUES ('xxx');
-ERROR:  invalid input syntax for integer: "xxx"
+ERROR:  invalid input syntax for type bigint: "xxx"
 LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('xxx');
                                          ^
 INSERT INTO INT8_TBL(q1) VALUES ('3908203590239580293850293850329485');
@@ -32,15 +32,15 @@ ERROR:  value "-1204982019841029840928340329840934" is out of range for type big
 LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('-1204982019841029840928340...
                                          ^
 INSERT INTO INT8_TBL(q1) VALUES ('- 123');
-ERROR:  invalid input syntax for integer: "- 123"
+ERROR:  invalid input syntax for type bigint: "- 123"
 LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('- 123');
                                          ^
 INSERT INTO INT8_TBL(q1) VALUES ('  345     5');
-ERROR:  invalid input syntax for integer: "  345     5"
+ERROR:  invalid input syntax for type bigint: "  345     5"
 LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('  345     5');
                                          ^
 INSERT INTO INT8_TBL(q1) VALUES ('');
-ERROR:  invalid input syntax for integer: ""
+ERROR:  invalid input syntax for type bigint: ""
 LINE 1: INSERT INTO INT8_TBL(q1) VALUES ('');
                                          ^
 SELECT * FROM INT8_TBL;
@@ -335,23 +335,23 @@ SELECT '' AS five, q1, q2, q1 / q2 AS divide, q1 % q2 AS mod FROM INT8_TBL;
 (5 rows)
 
 SELECT '' AS five, q1, float8(q1) FROM INT8_TBL;
- five |        q1        |        float8        
-------+------------------+----------------------
-      |              123 |                  123
-      |              123 |                  123
-      | 4567890123456789 | 4.56789012345679e+15
-      | 4567890123456789 | 4.56789012345679e+15
-      | 4567890123456789 | 4.56789012345679e+15
+ five |        q1        |        float8         
+------+------------------+-----------------------
+      |              123 |                   123
+      |              123 |                   123
+      | 4567890123456789 | 4.567890123456789e+15
+      | 4567890123456789 | 4.567890123456789e+15
+      | 4567890123456789 | 4.567890123456789e+15
 (5 rows)
 
 SELECT '' AS five, q2, float8(q2) FROM INT8_TBL;
- five |        q2         |        float8         
-------+-------------------+-----------------------
-      |               456 |                   456
-      |  4567890123456789 |  4.56789012345679e+15
-      | -4567890123456789 | -4.56789012345679e+15
-      |               123 |                   123
-      |  4567890123456789 |  4.56789012345679e+15
+ five |        q2         |         float8         
+------+-------------------+------------------------
+      |               456 |                    456
+      |  4567890123456789 |  4.567890123456789e+15
+      | -4567890123456789 | -4.567890123456789e+15
+      |               123 |                    123
+      |  4567890123456789 |  4.567890123456789e+15
 (5 rows)
 
 SELECT 37 + q1 AS plus4 FROM INT8_TBL;
@@ -713,13 +713,13 @@ SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 = 456;
 SELECT CAST(q1 AS int2) FROM int8_tbl WHERE q2 <> 456;
 ERROR:  smallint out of range
 SELECT CAST(q1 AS float4), CAST(q2 AS float8) FROM INT8_TBL;
-     q1      |          q2           
--------------+-----------------------
-         123 |                   456
-         123 |  4.56789012345679e+15
- 4.56789e+15 | -4.56789012345679e+15
- 4.56789e+15 |                   123
- 4.56789e+15 |  4.56789012345679e+15
+     q1      |           q2           
+-------------+------------------------
+         123 |                    456
+         123 |  4.567890123456789e+15
+ 4.56789e+15 | -4.567890123456789e+15
+ 4.56789e+15 |                    123
+ 4.56789e+15 |  4.567890123456789e+15
 (5 rows)
 
 SELECT CAST(q1 AS oid) FROM INT8_TBL;
diff --git a/expected/extra/join.out b/expected/extra/join.out
index e492a10..60a4545 100644
--- a/expected/extra/join.out
+++ b/expected/extra/join.out
@@ -32,7 +32,6 @@ CREATE FOREIGN TABLE tenk1 (
   stringu2  name,
   string4   name
 ) SERVER sqlite_svr;
-ALTER TABLE tenk1 SET WITH OIDS;
 CREATE FOREIGN TABLE tenk2 (
   unique1   int4,
   unique2   int4,
@@ -2244,24 +2243,14 @@ explain (costs off)
 select * from int8_tbl i1 left join (int8_tbl i2 join
   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
 order by 1, 2;
-                     QUERY PLAN                      
------------------------------------------------------
- Sort
-   Sort Key: i1.q1, i1.q2
-   ->  Merge Right Join
-         Merge Cond: (i2.q2 = i1.q2)
-         ->  Sort
-               Sort Key: i2.q2
-               ->  Hash Join
-                     Hash Cond: (i2.q1 = (123))
-                     ->  Foreign Scan on int8_tbl i2
-                     ->  Hash
-                           ->  Result
-         ->  Materialize
-               ->  Sort
-                     Sort Key: i1.q2
-                     ->  Foreign Scan on int8_tbl i1
-(15 rows)
+               QUERY PLAN                
+-----------------------------------------
+ Nested Loop Left Join
+   Join Filter: (i1.q2 = i2.q2)
+   ->  Foreign Scan on int8_tbl i1
+   ->  Materialize
+         ->  Foreign Scan on int8_tbl i2
+(5 rows)
 
 select * from int8_tbl i1 left join (int8_tbl i2 join
   (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
@@ -2329,50 +2318,49 @@ where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
 --
 -- check a case where we formerly got confused by conflicting sort orders
 -- in redundant merge join path keys
+-- PS: Used ORDER BY to force SQLite and PG12 always order in the same way (NULLS FIRST/LAST default value for PG and Sqlite are different)
 --
 explain (costs off)
 select * from
   j1_tbl full join
   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl
-  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
-                           QUERY PLAN                            
------------------------------------------------------------------
- Merge Full Join
-   Merge Cond: ((j2_tbl.i = j1_tbl.i) AND (j2_tbl.k = j1_tbl.i))
-   ->  Sort
-         Sort Key: j2_tbl.i DESC, j2_tbl.k
-         ->  Foreign Scan on j2_tbl
-   ->  Materialize
-         ->  Sort
-               Sort Key: j1_tbl.i DESC
-               ->  Foreign Scan on j1_tbl
-(9 rows)
+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k ORDER BY j1_tbl.i, j2_tbl.k;
+                              QUERY PLAN                              
+----------------------------------------------------------------------
+ Sort
+   Sort Key: j1_tbl.i, j2_tbl.k
+   ->  Hash Full Join
+         Hash Cond: ((j1_tbl.i = j2_tbl.i) AND (j1_tbl.i = j2_tbl.k))
+         ->  Foreign Scan on j1_tbl
+         ->  Hash
+               ->  Foreign Scan on j2_tbl
+(7 rows)
 
 select * from
   j1_tbl full join
   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl
-  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k ORDER BY j1_tbl.i, j2_tbl.k;
  i | j |   t   | i | k  
 ---+---+-------+---+----
-   |   |       |   |  0
-   |   |       |   |   
-   | 0 | zero  |   |   
-   |   | null  |   |   
- 8 | 8 | eight |   |   
- 7 | 7 | seven |   |   
+ 0 |   | zero  |   |   
+ 1 | 4 | one   |   |   
+ 2 | 3 | two   | 2 |  2
+ 3 | 2 | three |   |   
+ 4 | 1 | four  |   |   
+ 5 | 0 | five  |   |   
  6 | 6 | six   |   |   
+ 7 | 7 | seven |   |   
+ 8 | 8 | eight |   |   
    |   |       | 5 | -5
    |   |       | 5 | -5
- 5 | 0 | five  |   |   
- 4 | 1 | four  |   |   
    |   |       | 3 | -3
- 3 | 2 | three |   |   
- 2 | 3 | two   | 2 |  2
-   |   |       | 2 |  4
    |   |       | 1 | -1
+   |   |       |   |  0
+   |   |       | 2 |  4
+   |   |       |   |   
    |   |       | 0 |   
- 1 | 4 | one   |   |   
- 0 |   | zero  |   |   
+   | 0 | zero  |   |   
+   |   | null  |   |   
 (19 rows)
 
 --
@@ -2384,22 +2372,16 @@ select count(*) from
   left join
   (select * from tenk1 y order by y.unique2) y
   on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;
-                                                  QUERY PLAN                                                  
---------------------------------------------------------------------------------------------------------------
+                                    QUERY PLAN                                    
+----------------------------------------------------------------------------------
  Aggregate
    ->  Merge Left Join
-         Merge Cond: ((x.thousand = y.unique2) AND (x.twothousand = y.hundred) AND (x.fivethous = y.unique2))
-         ->  Sort
-               Sort Key: x.thousand, x.twothousand, x.fivethous
-               ->  Foreign Scan on tenk1 x
+         Merge Cond: (x.thousand = y.unique2)
+         Join Filter: ((x.twothousand = y.hundred) AND (x.fivethous = y.unique2))
+         ->  Foreign Scan on tenk1 x
          ->  Materialize
-               ->  Sort
-                     Sort Key: y.unique2, y.hundred
-                     ->  Subquery Scan on y
-                           ->  Sort
-                                 Sort Key: y_1.unique2
-                                 ->  Foreign Scan on tenk1 y_1
-(13 rows)
+               ->  Foreign Scan on tenk1 y
+(7 rows)
 
 select count(*) from
   (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x
@@ -2936,22 +2918,21 @@ select * from
 where
   1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
 order by 1,2;
-                        QUERY PLAN                         
------------------------------------------------------------
+                     QUERY PLAN                      
+-----------------------------------------------------
  Sort
    Sort Key: t1.q1, t1.q2
-   ->  Hash Left Join
-         Hash Cond: (t1.q2 = t2.q1)
+   ->  Hash Right Join
+         Hash Cond: (t2.q1 = t1.q2)
          Filter: (1 = (SubPlan 1))
-         ->  Foreign Scan on int8_tbl t1
+         ->  Foreign Scan on int8_tbl t2
          ->  Hash
-               ->  Foreign Scan on int8_tbl t2
+               ->  Foreign Scan on int8_tbl t1
          SubPlan 1
-           ->  Limit
-                 ->  Result
-                       One-Time Filter: ((42) IS NOT NULL)
-                       ->  Foreign Scan on int8_tbl t3
-(13 rows)
+           ->  Result
+                 One-Time Filter: ((42) IS NOT NULL)
+                 ->  Foreign Scan on int8_tbl t3
+(12 rows)
 
 select * from
   int8_tbl t1 left join
@@ -3116,34 +3097,22 @@ select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
   left join tenk1 t2
   on (subq1.y1 = t2.unique1)
 where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
-                              QUERY PLAN                              
-----------------------------------------------------------------------
+                          QUERY PLAN                          
+--------------------------------------------------------------
  Merge Join
-   Merge Cond: (i1.f1 = (0))
+   Merge Cond: (((11) = t1.unique2) AND ((3) = t2.unique1))
    ->  Sort
-         Sort Key: i1.f1
+         Sort Key: (11), (3)
          ->  Foreign Scan on int4_tbl i1
    ->  Materialize
          ->  Sort
-               Sort Key: (0)
-               ->  Merge Join
-                     Merge Cond: ((3) = t2.unique1)
+               Sort Key: t1.unique2, t2.unique1
+               ->  Nested Loop
                      Join Filter: (t1.stringu1 > t2.stringu2)
-                     ->  Sort
-                           Sort Key: (3)
-                           ->  Hash Join
-                                 Hash Cond: (t1.unique2 = (11))
-                                 ->  Foreign Scan on tenk1 t1
-                                 ->  Hash
-                                       ->  Nested Loop
-                                             Join Filter: ((1) = (1))
-                                             ->  Result
-                                             ->  Result
+                     ->  Foreign Scan on tenk1 t1
                      ->  Materialize
-                           ->  Sort
-                                 Sort Key: t2.unique1
-                                 ->  Foreign Scan on tenk1 t2
-(25 rows)
+                           ->  Foreign Scan on tenk1 t2
+(13 rows)
 
 select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
   tenk1 t1
@@ -3331,8 +3300,8 @@ select b.unique1 from
   join int4_tbl i1 on b.thousand = f1
   right join int4_tbl i2 on i2.f1 = b.tenthous
   order by 1;
-                                           QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
+                                         QUERY PLAN                                         
+--------------------------------------------------------------------------------------------
  Sort
    Sort Key: b.unique1
    ->  Merge Left Join
@@ -3356,20 +3325,16 @@ select b.unique1 from
                                              Join Filter: (b.unique1 = 42)
                                              ->  Sort
                                                    Sort Key: a.thousand
-                                                   ->  Merge Join
-                                                         Merge Cond: (a.unique1 = b.unique2)
-                                                         ->  Sort
-                                                               Sort Key: a.unique1
-                                                               ->  Foreign Scan on tenk1 a
-                                                         ->  Materialize
-                                                               ->  Sort
-                                                                     Sort Key: b.unique2
-                                                                     ->  Foreign Scan on tenk1 b
+                                                   ->  Hash Join
+                                                         Hash Cond: (a.unique1 = b.unique2)
+                                                         ->  Foreign Scan on tenk1 a
+                                                         ->  Hash
+                                                               ->  Foreign Scan on tenk1 b
                                              ->  Materialize
                                                    ->  Sort
                                                          Sort Key: c.thousand
                                                          ->  Foreign Scan on tenk1 c
-(36 rows)
+(32 rows)
 
 select b.unique1 from
   tenk1 a join tenk1 b on a.unique1 = b.unique2
@@ -3649,7 +3614,7 @@ select t1.* from
                                        ->  Sort
                                              Output: i8.q2, (NULL::integer)
                                              Sort Key: (NULL::integer)
-                                             ->  Merge Left Join
+                                             ->  Merge Join
                                                    Output: i8.q2, (NULL::integer)
                                                    Merge Cond: (i8.q1 = i8b2.q1)
                                                    ->  Sort
@@ -3953,12 +3918,10 @@ where t1.f1 = ss.f1;
                ->  Foreign Scan on public.int8_tbl i8
                      Output: i8.q1, i8.q2
                      SQLite query: SELECT `q1`, `q2` FROM main."int8_tbl" WHERE ((`q2` = 123))
-   ->  Limit
-         Output: (i8.q1), t2.f1
-         ->  Foreign Scan on public.text_tbl t2
-               Output: i8.q1, t2.f1
-               SQLite query: SELECT `f1` FROM main."text_tbl"
-(18 rows)
+   ->  Foreign Scan on public.text_tbl t2
+         Output: i8.q1, t2.f1
+         SQLite query: SELECT `f1` FROM main."text_tbl" LIMIT 1
+(16 rows)
 
 select * from
   text_tbl t1
@@ -3996,17 +3959,13 @@ where t1.f1 = ss2.f1;
                      ->  Foreign Scan on public.int8_tbl i8
                            Output: i8.q1, i8.q2
                            SQLite query: SELECT `q1`, `q2` FROM main."int8_tbl" WHERE ((`q2` = 123))
-         ->  Limit
-               Output: (i8.q1), t2.f1
-               ->  Foreign Scan on public.text_tbl t2
-                     Output: i8.q1, t2.f1
-                     SQLite query: SELECT `f1` FROM main."text_tbl"
-   ->  Limit
-         Output: ((i8.q1)), (t2.f1)
-         ->  Foreign Scan on public.text_tbl t3
-               Output: (i8.q1), t2.f1
-               SQLite query: SELECT NULL FROM main."text_tbl"
-(25 rows)
+         ->  Foreign Scan on public.text_tbl t2
+               Output: i8.q1, t2.f1
+               SQLite query: SELECT `f1` FROM main."text_tbl" LIMIT 1
+   ->  Foreign Scan on public.text_tbl t3
+         Output: (i8.q1), t2.f1
+         SQLite query: SELECT NULL FROM main."text_tbl" LIMIT 1
+(21 rows)
 
 select * from
   text_tbl t1
@@ -4058,12 +4017,10 @@ where tt1.f1 = ss1.c0;
    ->  Subquery Scan on ss1
          Output: ss1.c0
          Filter: (ss1.c0 = 'foo'::text)
-         ->  Limit
-               Output: (tt4.f1)
-               ->  Foreign Scan on public.text_tbl tt5
-                     Output: tt4.f1
-                     SQLite query: SELECT NULL FROM main."text_tbl"
-(33 rows)
+         ->  Foreign Scan on public.text_tbl tt5
+               Output: tt4.f1
+               SQLite query: SELECT NULL FROM main."text_tbl" LIMIT 1
+(31 rows)
 
 select 1 from
   text_tbl as tt1
@@ -4122,12 +4079,10 @@ where ss1.c2 = 0;
                                        ->  Foreign Scan on public.int4_tbl i43
                                              Output: i43.f1
                                              SQLite query: SELECT `f1` FROM main."int4_tbl" WHERE ((`f1` = 0))
-         ->  Limit
-               Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))
-               ->  Foreign Scan on public.text_tbl
-                     Output: i41.f1, i8.q1, i8.q2, i42.f1, i43.f1, (42)
-                     SQLite query: SELECT NULL FROM main."text_tbl"
-(36 rows)
+         ->  Foreign Scan on public.text_tbl
+               Output: i41.f1, i8.q1, i8.q2, i42.f1, i43.f1, (42)
+               SQLite query: SELECT NULL FROM main."text_tbl" LIMIT 1
+(34 rows)
 
 select ss2.* from
   int4_tbl i41
@@ -4154,10 +4109,10 @@ select * from
               QUERY PLAN               
 ---------------------------------------
  Nested Loop Left Join
-   Join Filter: ((1) = COALESCE((1)))
    ->  Result
    ->  Hash Full Join
          Hash Cond: (a1.unique1 = (1))
+         Filter: (1 = COALESCE((1)))
          ->  Foreign Scan on tenk1 a1
          ->  Hash
                ->  Result
@@ -4379,21 +4334,16 @@ select d3.* from d3 left join (select * from b3 group by b3.id, b3.c_id) s
 explain (costs off)
 select d3.* from d3 left join (select distinct * from b3) s
   on d3.a = s.id;
-                  QUERY PLAN                   
------------------------------------------------
- Merge Right Join
-   Merge Cond: (s.id = d3.a)
-   ->  Sort
-         Sort Key: s.id
+                 QUERY PLAN                 
+--------------------------------------------
+ Hash Left Join
+   Hash Cond: (d3.a = s.id)
+   ->  Foreign Scan on d3
+   ->  Hash
          ->  Subquery Scan on s
-               ->  HashAggregate
-                     Group Key: b3.id, b3.c_id
+               ->  Unique
                      ->  Foreign Scan on b3
-   ->  Materialize
-         ->  Sort
-               Sort Key: d3.a
-               ->  Foreign Scan on d3
-(12 rows)
+(7 rows)
 
 -- check join removal works when uniqueness of the join condition is enforced
 -- by a UNION
@@ -4575,25 +4525,25 @@ select t1.* from
   on t1.f1 = t2.f1
   left join uniquetbl t3
   on t2.d1 = t3.f1;
-                          QUERY PLAN                           
----------------------------------------------------------------
- Merge Right Join
-   Merge Cond: (t3.f1 = ('***'::text))
+                            QUERY PLAN                            
+------------------------------------------------------------------
+ Merge Left Join
+   Merge Cond: (t1.f1 = uniquetbl.f1)
    ->  Sort
-         Sort Key: t3.f1
-         ->  Foreign Scan on uniquetbl t3
+         Sort Key: t1.f1
+         ->  Foreign Scan on uniquetbl t1
    ->  Materialize
          ->  Sort
-               Sort Key: ('***'::text)
+               Sort Key: uniquetbl.f1
                ->  Merge Left Join
-                     Merge Cond: (t1.f1 = uniquetbl.f1)
+                     Merge Cond: (('***'::text) = t3.f1)
                      ->  Sort
-                           Sort Key: t1.f1
-                           ->  Foreign Scan on uniquetbl t1
+                           Sort Key: ('***'::text)
+                           ->  Foreign Scan on uniquetbl
                      ->  Materialize
                            ->  Sort
-                                 Sort Key: uniquetbl.f1
-                                 ->  Foreign Scan on uniquetbl
+                                 Sort Key: t3.f1
+                                 ->  Foreign Scan on uniquetbl t3
 (17 rows)
 
 explain (costs off)
@@ -4608,8 +4558,8 @@ from
      left join uniquetbl u1 ON u1.f1 = t1.string4) ss
   on t0.f1 = ss.case1
 where ss.stringu2 !~* ss.case1;
-                                                           QUERY PLAN                                                           
---------------------------------------------------------------------------------------------------------------------------------
+                                                              QUERY PLAN                                                              
+--------------------------------------------------------------------------------------------------------------------------------------
  Merge Join
    Merge Cond: (i4.f1 = t1.unique2)
    ->  Sort
@@ -4618,24 +4568,24 @@ where ss.stringu2 !~* ss.case1;
    ->  Materialize
          ->  Sort
                Sort Key: t1.unique2
-               ->  Merge Join
-                     Merge Cond: (t0.f1 = (CASE t1.ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END))
+               ->  Merge Right Join
+                     Merge Cond: (u1.f1 = t1.string4)
                      ->  Sort
-                           Sort Key: t0.f1
-                           ->  Foreign Scan on text_tbl t0
+                           Sort Key: u1.f1 COLLATE "C"
+                           ->  Foreign Scan on uniquetbl u1
                      ->  Materialize
                            ->  Sort
-                                 Sort Key: (CASE t1.ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
-                                 ->  Merge Left Join
-                                       Merge Cond: (((t1.string4)::text) = u1.f1)
+                                 Sort Key: t1.string4
+                                 ->  Merge Join
+                                       Merge Cond: (t0.f1 = (CASE t1.ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END))
                                        ->  Sort
-                                             Sort Key: ((t1.string4)::text)
-                                             ->  Foreign Scan on tenk1 t1
-                                                   Filter: (stringu2 !~* CASE ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
+                                             Sort Key: t0.f1
+                                             ->  Foreign Scan on text_tbl t0
                                        ->  Materialize
                                              ->  Sort
-                                                   Sort Key: u1.f1
-                                                   ->  Foreign Scan on uniquetbl u1
+                                                   Sort Key: (CASE t1.ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
+                                                   ->  Foreign Scan on tenk1 t1
+                                                         Filter: (stringu2 !~* CASE ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)
 (26 rows)
 
 select t0.*
@@ -5833,8 +5783,8 @@ select * from j11 natural join j21;
 explain (verbose, costs off)
 select * from j11
 inner join (select distinct id from j31) j31 on j11.id = j31.id;
-                          QUERY PLAN                           
----------------------------------------------------------------
+                                         QUERY PLAN                                         
+--------------------------------------------------------------------------------------------
  Hash Join
    Output: j11.id, j31.id
    Inner Unique: true
@@ -5844,13 +5794,12 @@ inner join (select distinct id from j31) j31 on j11.id = j31.id;
          SQLite query: SELECT `id` FROM main."j11"
    ->  Hash
          Output: j31.id
-         ->  HashAggregate
+         ->  Unique
                Output: j31.id
-               Group Key: j31.id
                ->  Foreign Scan on public.j31
                      Output: j31.id
-                     SQLite query: SELECT `id` FROM main."j31"
-(15 rows)
+                     SQLite query: SELECT `id` FROM main."j31" ORDER BY `id` ASC NULLS LAST
+(14 rows)
 
 -- ensure group by clause allows the inner to become unique
 explain (verbose, costs off)
diff --git a/expected/extra/limit.out b/expected/extra/limit.out
index 5d48ade..0d1a258 100644
--- a/expected/extra/limit.out
+++ b/expected/extra/limit.out
@@ -42,6 +42,27 @@ CREATE FOREIGN TABLE tenk1 (
 	stringu2	name,
 	string4		name
 ) SERVER sqlite_svr;
+CREATE TABLE parent_table (
+	unique1		int4 PRIMARY KEY,
+	unique2		int4,
+	two 		int4,
+	four		int4,
+	ten 		int4,
+	twenty		int4,
+	hundred		int4,
+	thousand	int4,
+	twothousand	int4,
+	fivethous	int4,
+	tenthous	int4,
+	odd			int4,
+	even		int4,
+	stringu1	name,
+	stringu2	name,
+	string4		name
+);
+CREATE FOREIGN table inherited_table ()
+INHERITS (parent_table)
+SERVER sqlite_svr options (table 'tenk1');
 SELECT ''::text AS two, unique1, unique2, stringu1
 		FROM onek WHERE unique1 > 50
 		ORDER BY unique1 LIMIT 2;
@@ -200,19 +221,12 @@ create temp sequence testseq;
 explain (verbose, costs off)
 select unique1, unique2, nextval('testseq')
   from tenk1 order by unique2 limit 10;
-                                   QUERY PLAN                                    
----------------------------------------------------------------------------------
- Limit
-   Output: unique1, unique2, (nextval('testseq'::regclass))
-   ->  Result
-         Output: unique1, unique2, nextval('testseq'::regclass)
-         ->  Sort
-               Output: unique1, unique2
-               Sort Key: tenk1.unique2
-               ->  Foreign Scan on public.tenk1
-                     Output: unique1, unique2
-                     SQLite query: SELECT `unique1`, `unique2` FROM main."tenk1"
-(10 rows)
+                                                QUERY PLAN                                                
+----------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.tenk1
+   Output: unique1, unique2, nextval('testseq'::regclass)
+   SQLite query: SELECT `unique1`, `unique2` FROM main."tenk1" ORDER BY `unique2` ASC NULLS LAST LIMIT 10
+(3 rows)
 
 select unique1, unique2, nextval('testseq')
   from tenk1 order by unique2 limit 10;
@@ -230,67 +244,249 @@ select unique1, unique2, nextval('testseq')
     3043 |       9 |      10
 (10 rows)
 
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 limit 10 offset 5;
+                                                    QUERY PLAN                                                     
+-------------------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.tenk1
+   Output: unique1, unique2, nextval('testseq'::regclass)
+   SQLite query: SELECT `unique1`, `unique2` FROM main."tenk1" ORDER BY `unique2` ASC NULLS LAST LIMIT 10 OFFSET 5
+(3 rows)
+
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 limit 10 offset 5;
+ unique1 | unique2 | nextval 
+---------+---------+---------
+    8009 |       5 |      11
+    5057 |       6 |      12
+    6701 |       7 |      13
+    4321 |       8 |      14
+    3043 |       9 |      15
+    1314 |      10 |      16
+    1504 |      11 |      17
+    5222 |      12 |      18
+    6243 |      13 |      19
+    5471 |      14 |      20
+(10 rows)
+
 select currval('testseq');
  currval 
 ---------
-      10
+      20
 (1 row)
 
 explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 desc limit 10;
+                                                 QUERY PLAN                                                 
+------------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.tenk1
+   Output: unique1, unique2, nextval('testseq'::regclass)
+   SQLite query: SELECT `unique1`, `unique2` FROM main."tenk1" ORDER BY `unique2` DESC NULLS FIRST LIMIT 10
+(3 rows)
+
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 desc limit 10;
+ unique1 | unique2 | nextval 
+---------+---------+---------
+    2968 |    9999 |      21
+       0 |    9998 |      22
+    2992 |    9997 |      23
+    1783 |    9996 |      24
+    5780 |    9995 |      25
+     429 |    9994 |      26
+    6093 |    9993 |      27
+    6587 |    9992 |      28
+    4093 |    9991 |      29
+    4773 |    9990 |      30
+(10 rows)
+
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 desc limit 10 offset 5;
+                                                     QUERY PLAN                                                      
+---------------------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.tenk1
+   Output: unique1, unique2, nextval('testseq'::regclass)
+   SQLite query: SELECT `unique1`, `unique2` FROM main."tenk1" ORDER BY `unique2` DESC NULLS FIRST LIMIT 10 OFFSET 5
+(3 rows)
+
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 desc limit 10 offset 5;
+ unique1 | unique2 | nextval 
+---------+---------+---------
+     429 |    9994 |      31
+    6093 |    9993 |      32
+    6587 |    9992 |      33
+    4093 |    9991 |      34
+    4773 |    9990 |      35
+    8592 |    9989 |      36
+     858 |    9988 |      37
+    9194 |    9987 |      38
+    1384 |    9986 |      39
+    2406 |    9985 |      40
+(10 rows)
+
+select currval('testseq');
+ currval 
+---------
+      40
+(1 row)
+
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by tenthous limit 10;
+                                                      QUERY PLAN                                                       
+-----------------------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.tenk1
+   Output: unique1, unique2, nextval('testseq'::regclass), tenthous
+   SQLite query: SELECT `unique1`, `unique2`, `tenthous` FROM main."tenk1" ORDER BY `tenthous` ASC NULLS LAST LIMIT 10
+(3 rows)
+
 select unique1, unique2, nextval('testseq')
   from tenk1 order by tenthous limit 10;
-                                         QUERY PLAN                                          
----------------------------------------------------------------------------------------------
+ unique1 | unique2 | nextval 
+---------+---------+---------
+       0 |    9998 |      41
+       1 |    2838 |      42
+       2 |    2716 |      43
+       3 |    5679 |      44
+       4 |    1621 |      45
+       5 |    5557 |      46
+       6 |    2855 |      47
+       7 |    8518 |      48
+       8 |    5435 |      49
+       9 |    4463 |      50
+(10 rows)
+
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by tenthous limit 10 offset 5;
+                                                           QUERY PLAN                                                           
+--------------------------------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.tenk1
+   Output: unique1, unique2, nextval('testseq'::regclass), tenthous
+   SQLite query: SELECT `unique1`, `unique2`, `tenthous` FROM main."tenk1" ORDER BY `tenthous` ASC NULLS LAST LIMIT 10 OFFSET 5
+(3 rows)
+
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by tenthous limit 10 offset 5;
+ unique1 | unique2 | nextval 
+---------+---------+---------
+       5 |    5557 |      51
+       6 |    2855 |      52
+       7 |    8518 |      53
+       8 |    5435 |      54
+       9 |    4463 |      55
+      10 |    8788 |      56
+      11 |    8396 |      57
+      12 |    6605 |      58
+      13 |    5696 |      59
+      14 |    4341 |      60
+(10 rows)
+
+select currval('testseq');
+ currval 
+---------
+      60
+(1 row)
+
+-- test for limit and offset when querying table and foreign table inherited
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from parent_table order by tenthous limit 10;
+                                                               QUERY PLAN                                                                
+-----------------------------------------------------------------------------------------------------------------------------------------
  Limit
-   Output: unique1, unique2, (nextval('testseq'::regclass)), tenthous
+   Output: parent_table.unique1, parent_table.unique2, (nextval('testseq'::regclass)), parent_table.tenthous
    ->  Result
-         Output: unique1, unique2, nextval('testseq'::regclass), tenthous
-         ->  Sort
-               Output: unique1, unique2, tenthous
-               Sort Key: tenk1.tenthous
-               ->  Foreign Scan on public.tenk1
-                     Output: unique1, unique2, tenthous
-                     SQLite query: SELECT `unique1`, `unique2`, `tenthous` FROM main."tenk1"
+         Output: parent_table.unique1, parent_table.unique2, nextval('testseq'::regclass), parent_table.tenthous
+         ->  Merge Append
+               Sort Key: parent_table.tenthous
+               ->  Sort
+                     Output: parent_table.unique1, parent_table.unique2, parent_table.tenthous
+                     Sort Key: parent_table.tenthous
+                     ->  Seq Scan on public.parent_table
+                           Output: parent_table.unique1, parent_table.unique2, parent_table.tenthous
+               ->  Foreign Scan on public.inherited_table
+                     Output: inherited_table.unique1, inherited_table.unique2, inherited_table.tenthous
+                     SQLite query: SELECT `unique1`, `unique2`, `tenthous` FROM main."tenk1" ORDER BY `tenthous` ASC NULLS LAST LIMIT 10
+(14 rows)
+
+select unique1, unique2, nextval('testseq')
+  from parent_table order by tenthous limit 10;
+ unique1 | unique2 | nextval 
+---------+---------+---------
+       0 |    9998 |      61
+       1 |    2838 |      62
+       2 |    2716 |      63
+       3 |    5679 |      64
+       4 |    1621 |      65
+       5 |    5557 |      66
+       6 |    2855 |      67
+       7 |    8518 |      68
+       8 |    5435 |      69
+       9 |    4463 |      70
 (10 rows)
 
+-- when querying regular tables with inherited tables, only limit is pushed-down when no offset is specified
+explain (verbose, costs off)
 select unique1, unique2, nextval('testseq')
-  from tenk1 order by tenthous limit 10;
+  from parent_table order by tenthous limit 10 offset 5;
+                                                           QUERY PLAN                                                           
+--------------------------------------------------------------------------------------------------------------------------------
+ Limit
+   Output: parent_table.unique1, parent_table.unique2, (nextval('testseq'::regclass)), parent_table.tenthous
+   ->  Result
+         Output: parent_table.unique1, parent_table.unique2, nextval('testseq'::regclass), parent_table.tenthous
+         ->  Merge Append
+               Sort Key: parent_table.tenthous
+               ->  Sort
+                     Output: parent_table.unique1, parent_table.unique2, parent_table.tenthous
+                     Sort Key: parent_table.tenthous
+                     ->  Seq Scan on public.parent_table
+                           Output: parent_table.unique1, parent_table.unique2, parent_table.tenthous
+               ->  Foreign Scan on public.inherited_table
+                     Output: inherited_table.unique1, inherited_table.unique2, inherited_table.tenthous
+                     SQLite query: SELECT `unique1`, `unique2`, `tenthous` FROM main."tenk1" ORDER BY `tenthous` ASC NULLS LAST
+(14 rows)
+
+select unique1, unique2, nextval('testseq')
+  from parent_table order by tenthous limit 10 offset 5;
  unique1 | unique2 | nextval 
 ---------+---------+---------
-       0 |    9998 |      11
-       1 |    2838 |      12
-       2 |    2716 |      13
-       3 |    5679 |      14
-       4 |    1621 |      15
-       5 |    5557 |      16
-       6 |    2855 |      17
-       7 |    8518 |      18
-       8 |    5435 |      19
-       9 |    4463 |      20
+       5 |    5557 |      76
+       6 |    2855 |      77
+       7 |    8518 |      78
+       8 |    5435 |      79
+       9 |    4463 |      80
+      10 |    8788 |      81
+      11 |    8396 |      82
+      12 |    6605 |      83
+      13 |    5696 |      84
+      14 |    4341 |      85
 (10 rows)
 
 select currval('testseq');
  currval 
 ---------
-      20
+      85
 (1 row)
 
 explain (verbose, costs off)
 select unique1, unique2, generate_series(1,10)
   from tenk1 order by unique2 limit 7;
-                                   QUERY PLAN                                    
----------------------------------------------------------------------------------
+                                                                         QUERY PLAN                                                                          
+-------------------------------------------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: unique1, unique2, (generate_series(1, 10))
    ->  ProjectSet
          Output: unique1, unique2, generate_series(1, 10)
-         ->  Sort
-               Output: unique1, unique2
-               Sort Key: tenk1.unique2
-               ->  Foreign Scan on public.tenk1
-                     Output: unique1, unique2
-                     SQLite query: SELECT `unique1`, `unique2` FROM main."tenk1"
-(10 rows)
+         ->  Foreign Scan on public.tenk1
+               Output: unique1, unique2, two, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4
+               SQLite query: SELECT `unique1`, `unique2` FROM main."tenk1" ORDER BY `unique2` ASC NULLS LAST
+(7 rows)
 
 select unique1, unique2, generate_series(1,10)
   from tenk1 order by unique2 limit 7;
@@ -308,19 +504,16 @@ select unique1, unique2, generate_series(1,10)
 explain (verbose, costs off)
 select unique1, unique2, generate_series(1,10)
   from tenk1 order by tenthous limit 7;
-                                         QUERY PLAN                                          
----------------------------------------------------------------------------------------------
+                                                                         QUERY PLAN                                                                          
+-------------------------------------------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: unique1, unique2, (generate_series(1, 10)), tenthous
    ->  ProjectSet
          Output: unique1, unique2, generate_series(1, 10), tenthous
-         ->  Sort
-               Output: unique1, unique2, tenthous
-               Sort Key: tenk1.tenthous
-               ->  Foreign Scan on public.tenk1
-                     Output: unique1, unique2, tenthous
-                     SQLite query: SELECT `unique1`, `unique2`, `tenthous` FROM main."tenk1"
-(10 rows)
+         ->  Foreign Scan on public.tenk1
+               Output: unique1, unique2, two, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4
+               SQLite query: SELECT `unique1`, `unique2`, `tenthous` FROM main."tenk1" ORDER BY `tenthous` ASC NULLS LAST
+(7 rows)
 
 select unique1, unique2, generate_series(1,10)
   from tenk1 order by tenthous limit 7;
@@ -339,19 +532,14 @@ select unique1, unique2, generate_series(1,10)
 explain (verbose, costs off)
 select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2
   from tenk1 group by thousand order by thousand limit 3;
-                                                      QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
+                                                        QUERY PLAN                                                        
+--------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: (sum(tenthous)), ((((sum(tenthous)))::double precision + (random() * '0'::double precision))), thousand
-   ->  Result
+   ->  Foreign Scan
          Output: (sum(tenthous)), (((sum(tenthous)))::double precision + (random() * '0'::double precision)), thousand
-         ->  Sort
-               Output: (sum(tenthous)), thousand
-               Sort Key: tenk1.thousand
-               ->  Foreign Scan
-                     Output: (sum(tenthous)), thousand
-                     SQLite query: SELECT sum(`tenthous`), `thousand` FROM main."tenk1" GROUP BY 2
-(10 rows)
+         SQLite query: SELECT sum(`tenthous`), `thousand` FROM main."tenk1" GROUP BY 2 ORDER BY `thousand` ASC NULLS LAST
+(5 rows)
 
 select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2
   from tenk1 group by thousand order by thousand limit 3;
@@ -364,6 +552,8 @@ select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2
 
 DROP FOREIGN TABLE onek;
 DROP FOREIGN TABLE int8_tbl;
+DROP FOREIGN TABLE inherited_table;
+DROP TABLE parent_table;
 DROP FOREIGN TABLE tenk1;
 DROP SERVER sqlite_svr;
 DROP EXTENSION sqlite_fdw CASCADE;
diff --git a/expected/extra/numeric.out b/expected/extra/numeric.out
index 253130a..b408456 100644
--- a/expected/extra/numeric.out
+++ b/expected/extra/numeric.out
@@ -701,7 +701,7 @@ INSERT INTO ceil_floor_round VALUES ('9.4999999');
 INSERT INTO ceil_floor_round VALUES ('0.0');
 INSERT INTO ceil_floor_round VALUES ('0.0000001');
 INSERT INTO ceil_floor_round VALUES ('-0.000001');
-SELECT a, ceil(a), ceiling(a), floor(a), round(a) FROM ceil_floor_round;
+SELECT a, ceil(a), ceiling(a), floor(a), round(a) FROM ceil_floor_round ORDER BY a;
      a      | ceil | ceiling | floor | round 
 ------------+------+---------+-------+-------
        -5.5 |   -5 |      -5 |    -6 |    -6
diff --git a/expected/extra/prepare.out b/expected/extra/prepare.out
index e6ce319..c196ced 100644
--- a/expected/extra/prepare.out
+++ b/expected/extra/prepare.out
@@ -20,9 +20,9 @@ CREATE FOREIGN TABLE tenk1 (
 	even		int4,
 	stringu1	name,
 	stringu2	name,
-	string4		name
+	string4		name,
+    oid         oid
 ) SERVER sqlite_svr;
-ALTER TABLE tenk1 SET WITH OIDS;
 CREATE FOREIGN TABLE road (
 	name		text,
 	thepath 	path
@@ -52,9 +52,9 @@ ERROR:  prepared statement "q1" already exists
 DEALLOCATE q1;
 PREPARE q1 AS SELECT * FROM tenk1 LIMIT 1;
 EXECUTE q1;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-    8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx
+ unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | oid 
+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+-----
+    8800 |       0 |   0 |    0 |   0 |      0 |       0 |      800 |         800 |      3800 |     8800 |   0 |    1 | MAAAAA   | AAAAAA   | AAAAxx  |   1
 (1 row)
 
 PREPARE q2 AS SELECT * FROM tenk1 LIMIT 1;
@@ -95,37 +95,37 @@ PREPARE q3(text, int, float, boolean, oid, smallint) AS
 	ten = $3::bigint OR true = $4 OR oid = $5 OR odd = $6::int)
 	ORDER BY unique1;
 EXECUTE q3('AAAAxx', 5::smallint, 10.5::float, false, 500::oid, 4::bigint);
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-       2 |    2716 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | MAEAAA   | AAAAxx
-     102 |     612 |   0 |    2 |   2 |      2 |       2 |      102 |         102 |       102 |      102 |   4 |    5 | YDAAAA   | OXAAAA   | AAAAxx
-     802 |    2908 |   0 |    2 |   2 |      2 |       2 |      802 |         802 |       802 |      802 |   4 |    5 | WEAAAA   | WHEAAA   | AAAAxx
-     902 |    1104 |   0 |    2 |   2 |      2 |       2 |      902 |         902 |       902 |      902 |   4 |    5 | SIAAAA   | MQBAAA   | AAAAxx
-    1002 |    2580 |   0 |    2 |   2 |      2 |       2 |        2 |        1002 |      1002 |     1002 |   4 |    5 | OMAAAA   | GVDAAA   | AAAAxx
-    1602 |    8148 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |      1602 |     1602 |   4 |    5 | QJAAAA   | KBMAAA   | AAAAxx
-    1702 |    7940 |   0 |    2 |   2 |      2 |       2 |      702 |        1702 |      1702 |     1702 |   4 |    5 | MNAAAA   | KTLAAA   | AAAAxx
-    2102 |    6184 |   0 |    2 |   2 |      2 |       2 |      102 |         102 |      2102 |     2102 |   4 |    5 | WCAAAA   | WDJAAA   | AAAAxx
-    2202 |    8028 |   0 |    2 |   2 |      2 |       2 |      202 |         202 |      2202 |     2202 |   4 |    5 | SGAAAA   | UWLAAA   | AAAAxx
-    2302 |    7112 |   0 |    2 |   2 |      2 |       2 |      302 |         302 |      2302 |     2302 |   4 |    5 | OKAAAA   | ONKAAA   | AAAAxx
-    2902 |    6816 |   0 |    2 |   2 |      2 |       2 |      902 |         902 |      2902 |     2902 |   4 |    5 | QHAAAA   | ECKAAA   | AAAAxx
-    3202 |    7128 |   0 |    2 |   2 |      2 |       2 |      202 |        1202 |      3202 |     3202 |   4 |    5 | ETAAAA   | EOKAAA   | AAAAxx
-    3902 |    9224 |   0 |    2 |   2 |      2 |       2 |      902 |        1902 |      3902 |     3902 |   4 |    5 | CUAAAA   | UQNAAA   | AAAAxx
-    4102 |    7676 |   0 |    2 |   2 |      2 |       2 |      102 |         102 |      4102 |     4102 |   4 |    5 | UBAAAA   | GJLAAA   | AAAAxx
-    4202 |    6628 |   0 |    2 |   2 |      2 |       2 |      202 |         202 |      4202 |     4202 |   4 |    5 | QFAAAA   | YUJAAA   | AAAAxx
-    4502 |     412 |   0 |    2 |   2 |      2 |       2 |      502 |         502 |      4502 |     4502 |   4 |    5 | ERAAAA   | WPAAAA   | AAAAxx
-    4702 |    2520 |   0 |    2 |   2 |      2 |       2 |      702 |         702 |      4702 |     4702 |   4 |    5 | WYAAAA   | YSDAAA   | AAAAxx
-    4902 |    1600 |   0 |    2 |   2 |      2 |       2 |      902 |         902 |      4902 |     4902 |   4 |    5 | OGAAAA   | OJCAAA   | AAAAxx
-    5602 |    8796 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |       602 |     5602 |   4 |    5 | MHAAAA   | IANAAA   | AAAAxx
-    6002 |    8932 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |      1002 |     6002 |   4 |    5 | WWAAAA   | OFNAAA   | AAAAxx
-    6402 |    3808 |   0 |    2 |   2 |      2 |       2 |      402 |         402 |      1402 |     6402 |   4 |    5 | GMAAAA   | MQFAAA   | AAAAxx
-    7602 |    1040 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |      2602 |     7602 |   4 |    5 | KGAAAA   | AOBAAA   | AAAAxx
-    7802 |    7508 |   0 |    2 |   2 |      2 |       2 |      802 |        1802 |      2802 |     7802 |   4 |    5 | COAAAA   | UCLAAA   | AAAAxx
-    8002 |    9980 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |      3002 |     8002 |   4 |    5 | UVAAAA   | WTOAAA   | AAAAxx
-    8302 |    7800 |   0 |    2 |   2 |      2 |       2 |      302 |         302 |      3302 |     8302 |   4 |    5 | IHAAAA   | AOLAAA   | AAAAxx
-    8402 |    5708 |   0 |    2 |   2 |      2 |       2 |      402 |         402 |      3402 |     8402 |   4 |    5 | ELAAAA   | OLIAAA   | AAAAxx
-    8602 |    5440 |   0 |    2 |   2 |      2 |       2 |      602 |         602 |      3602 |     8602 |   4 |    5 | WSAAAA   | GBIAAA   | AAAAxx
-    9502 |    1812 |   0 |    2 |   2 |      2 |       2 |      502 |        1502 |      4502 |     9502 |   4 |    5 | MBAAAA   | SRCAAA   | AAAAxx
-    9602 |    9972 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |      4602 |     9602 |   4 |    5 | IFAAAA   | OTOAAA   | AAAAxx
+ unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | oid  
+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+------
+       2 |    2716 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |         2 |        2 |   4 |    5 | CAAAAA   | MAEAAA   | AAAAxx  | 2717
+     102 |     612 |   0 |    2 |   2 |      2 |       2 |      102 |         102 |       102 |      102 |   4 |    5 | YDAAAA   | OXAAAA   | AAAAxx  |  613
+     802 |    2908 |   0 |    2 |   2 |      2 |       2 |      802 |         802 |       802 |      802 |   4 |    5 | WEAAAA   | WHEAAA   | AAAAxx  | 2909
+     902 |    1104 |   0 |    2 |   2 |      2 |       2 |      902 |         902 |       902 |      902 |   4 |    5 | SIAAAA   | MQBAAA   | AAAAxx  | 1105
+    1002 |    2580 |   0 |    2 |   2 |      2 |       2 |        2 |        1002 |      1002 |     1002 |   4 |    5 | OMAAAA   | GVDAAA   | AAAAxx  | 2581
+    1602 |    8148 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |      1602 |     1602 |   4 |    5 | QJAAAA   | KBMAAA   | AAAAxx  | 8149
+    1702 |    7940 |   0 |    2 |   2 |      2 |       2 |      702 |        1702 |      1702 |     1702 |   4 |    5 | MNAAAA   | KTLAAA   | AAAAxx  | 7941
+    2102 |    6184 |   0 |    2 |   2 |      2 |       2 |      102 |         102 |      2102 |     2102 |   4 |    5 | WCAAAA   | WDJAAA   | AAAAxx  | 6185
+    2202 |    8028 |   0 |    2 |   2 |      2 |       2 |      202 |         202 |      2202 |     2202 |   4 |    5 | SGAAAA   | UWLAAA   | AAAAxx  | 8029
+    2302 |    7112 |   0 |    2 |   2 |      2 |       2 |      302 |         302 |      2302 |     2302 |   4 |    5 | OKAAAA   | ONKAAA   | AAAAxx  | 7113
+    2902 |    6816 |   0 |    2 |   2 |      2 |       2 |      902 |         902 |      2902 |     2902 |   4 |    5 | QHAAAA   | ECKAAA   | AAAAxx  | 6817
+    3202 |    7128 |   0 |    2 |   2 |      2 |       2 |      202 |        1202 |      3202 |     3202 |   4 |    5 | ETAAAA   | EOKAAA   | AAAAxx  | 7129
+    3902 |    9224 |   0 |    2 |   2 |      2 |       2 |      902 |        1902 |      3902 |     3902 |   4 |    5 | CUAAAA   | UQNAAA   | AAAAxx  | 9225
+    4102 |    7676 |   0 |    2 |   2 |      2 |       2 |      102 |         102 |      4102 |     4102 |   4 |    5 | UBAAAA   | GJLAAA   | AAAAxx  | 7677
+    4202 |    6628 |   0 |    2 |   2 |      2 |       2 |      202 |         202 |      4202 |     4202 |   4 |    5 | QFAAAA   | YUJAAA   | AAAAxx  | 6629
+    4502 |     412 |   0 |    2 |   2 |      2 |       2 |      502 |         502 |      4502 |     4502 |   4 |    5 | ERAAAA   | WPAAAA   | AAAAxx  |  413
+    4702 |    2520 |   0 |    2 |   2 |      2 |       2 |      702 |         702 |      4702 |     4702 |   4 |    5 | WYAAAA   | YSDAAA   | AAAAxx  | 2521
+    4902 |    1600 |   0 |    2 |   2 |      2 |       2 |      902 |         902 |      4902 |     4902 |   4 |    5 | OGAAAA   | OJCAAA   | AAAAxx  | 1601
+    5602 |    8796 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |       602 |     5602 |   4 |    5 | MHAAAA   | IANAAA   | AAAAxx  | 8797
+    6002 |    8932 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |      1002 |     6002 |   4 |    5 | WWAAAA   | OFNAAA   | AAAAxx  | 8933
+    6402 |    3808 |   0 |    2 |   2 |      2 |       2 |      402 |         402 |      1402 |     6402 |   4 |    5 | GMAAAA   | MQFAAA   | AAAAxx  | 3809
+    7602 |    1040 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |      2602 |     7602 |   4 |    5 | KGAAAA   | AOBAAA   | AAAAxx  | 1041
+    7802 |    7508 |   0 |    2 |   2 |      2 |       2 |      802 |        1802 |      2802 |     7802 |   4 |    5 | COAAAA   | UCLAAA   | AAAAxx  | 7509
+    8002 |    9980 |   0 |    2 |   2 |      2 |       2 |        2 |           2 |      3002 |     8002 |   4 |    5 | UVAAAA   | WTOAAA   | AAAAxx  | 9981
+    8302 |    7800 |   0 |    2 |   2 |      2 |       2 |      302 |         302 |      3302 |     8302 |   4 |    5 | IHAAAA   | AOLAAA   | AAAAxx  | 7801
+    8402 |    5708 |   0 |    2 |   2 |      2 |       2 |      402 |         402 |      3402 |     8402 |   4 |    5 | ELAAAA   | OLIAAA   | AAAAxx  | 5709
+    8602 |    5440 |   0 |    2 |   2 |      2 |       2 |      602 |         602 |      3602 |     8602 |   4 |    5 | WSAAAA   | GBIAAA   | AAAAxx  | 5441
+    9502 |    1812 |   0 |    2 |   2 |      2 |       2 |      502 |        1502 |      4502 |     9502 |   4 |    5 | MBAAAA   | SRCAAA   | AAAAxx  | 1813
+    9602 |    9972 |   0 |    2 |   2 |      2 |       2 |      602 |        1602 |      4602 |     9602 |   4 |    5 | IFAAAA   | OTOAAA   | AAAAxx  | 9973
 (29 rows)
 
 -- too few params
@@ -151,24 +151,24 @@ PREPARE q5(int, text) AS
 	ORDER BY unique1;
 CREATE TEMPORARY TABLE q5_prep_results AS EXECUTE q5(200, 'DTAAAA');
 SELECT * FROM q5_prep_results;
- unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
----------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
-     200 |    9441 |   0 |    0 |   0 |      0 |       0 |      200 |         200 |       200 |      200 |   0 |    1 | SHAAAA   | DZNAAA   | HHHHxx
-     497 |    9092 |   1 |    1 |   7 |     17 |      97 |      497 |         497 |       497 |      497 | 194 |  195 | DTAAAA   | SLNAAA   | AAAAxx
-    1173 |    6699 |   1 |    1 |   3 |     13 |      73 |      173 |        1173 |      1173 |     1173 | 146 |  147 | DTAAAA   | RXJAAA   | VVVVxx
-    1849 |    8143 |   1 |    1 |   9 |      9 |      49 |      849 |        1849 |      1849 |     1849 |  98 |   99 | DTAAAA   | FBMAAA   | VVVVxx
-    2525 |      64 |   1 |    1 |   5 |      5 |      25 |      525 |         525 |      2525 |     2525 |  50 |   51 | DTAAAA   | MCAAAA   | AAAAxx
-    3201 |    7309 |   1 |    1 |   1 |      1 |       1 |      201 |        1201 |      3201 |     3201 |   2 |    3 | DTAAAA   | DVKAAA   | HHHHxx
-    3877 |    4060 |   1 |    1 |   7 |     17 |      77 |      877 |        1877 |      3877 |     3877 | 154 |  155 | DTAAAA   | EAGAAA   | AAAAxx
-    4553 |    4113 |   1 |    1 |   3 |     13 |      53 |      553 |         553 |      4553 |     4553 | 106 |  107 | DTAAAA   | FCGAAA   | HHHHxx
-    5229 |    6407 |   1 |    1 |   9 |      9 |      29 |      229 |        1229 |       229 |     5229 |  58 |   59 | DTAAAA   | LMJAAA   | VVVVxx
-    5905 |    9537 |   1 |    1 |   5 |      5 |       5 |      905 |        1905 |       905 |     5905 |  10 |   11 | DTAAAA   | VCOAAA   | HHHHxx
-    6581 |    4686 |   1 |    1 |   1 |      1 |      81 |      581 |         581 |      1581 |     6581 | 162 |  163 | DTAAAA   | GYGAAA   | OOOOxx
-    7257 |    1895 |   1 |    1 |   7 |     17 |      57 |      257 |        1257 |      2257 |     7257 | 114 |  115 | DTAAAA   | XUCAAA   | VVVVxx
-    7933 |    4514 |   1 |    1 |   3 |     13 |      33 |      933 |        1933 |      2933 |     7933 |  66 |   67 | DTAAAA   | QRGAAA   | OOOOxx
-    8609 |    5918 |   1 |    1 |   9 |      9 |       9 |      609 |         609 |      3609 |     8609 |  18 |   19 | DTAAAA   | QTIAAA   | OOOOxx
-    9285 |    8469 |   1 |    1 |   5 |      5 |      85 |      285 |        1285 |      4285 |     9285 | 170 |  171 | DTAAAA   | TNMAAA   | HHHHxx
-    9961 |    2058 |   1 |    1 |   1 |      1 |      61 |      961 |        1961 |      4961 |     9961 | 122 |  123 | DTAAAA   | EBDAAA   | OOOOxx
+ unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 | oid  
+---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------+------
+     200 |    9441 |   0 |    0 |   0 |      0 |       0 |      200 |         200 |       200 |      200 |   0 |    1 | SHAAAA   | DZNAAA   | HHHHxx  | 9442
+     497 |    9092 |   1 |    1 |   7 |     17 |      97 |      497 |         497 |       497 |      497 | 194 |  195 | DTAAAA   | SLNAAA   | AAAAxx  | 9093
+    1173 |    6699 |   1 |    1 |   3 |     13 |      73 |      173 |        1173 |      1173 |     1173 | 146 |  147 | DTAAAA   | RXJAAA   | VVVVxx  | 6700
+    1849 |    8143 |   1 |    1 |   9 |      9 |      49 |      849 |        1849 |      1849 |     1849 |  98 |   99 | DTAAAA   | FBMAAA   | VVVVxx  | 8144
+    2525 |      64 |   1 |    1 |   5 |      5 |      25 |      525 |         525 |      2525 |     2525 |  50 |   51 | DTAAAA   | MCAAAA   | AAAAxx  |   65
+    3201 |    7309 |   1 |    1 |   1 |      1 |       1 |      201 |        1201 |      3201 |     3201 |   2 |    3 | DTAAAA   | DVKAAA   | HHHHxx  | 7310
+    3877 |    4060 |   1 |    1 |   7 |     17 |      77 |      877 |        1877 |      3877 |     3877 | 154 |  155 | DTAAAA   | EAGAAA   | AAAAxx  | 4061
+    4553 |    4113 |   1 |    1 |   3 |     13 |      53 |      553 |         553 |      4553 |     4553 | 106 |  107 | DTAAAA   | FCGAAA   | HHHHxx  | 4114
+    5229 |    6407 |   1 |    1 |   9 |      9 |      29 |      229 |        1229 |       229 |     5229 |  58 |   59 | DTAAAA   | LMJAAA   | VVVVxx  | 6408
+    5905 |    9537 |   1 |    1 |   5 |      5 |       5 |      905 |        1905 |       905 |     5905 |  10 |   11 | DTAAAA   | VCOAAA   | HHHHxx  | 9538
+    6581 |    4686 |   1 |    1 |   1 |      1 |      81 |      581 |         581 |      1581 |     6581 | 162 |  163 | DTAAAA   | GYGAAA   | OOOOxx  | 4687
+    7257 |    1895 |   1 |    1 |   7 |     17 |      57 |      257 |        1257 |      2257 |     7257 | 114 |  115 | DTAAAA   | XUCAAA   | VVVVxx  | 1896
+    7933 |    4514 |   1 |    1 |   3 |     13 |      33 |      933 |        1933 |      2933 |     7933 |  66 |   67 | DTAAAA   | QRGAAA   | OOOOxx  | 4515
+    8609 |    5918 |   1 |    1 |   9 |      9 |       9 |      609 |         609 |      3609 |     8609 |  18 |   19 | DTAAAA   | QTIAAA   | OOOOxx  | 5919
+    9285 |    8469 |   1 |    1 |   5 |      5 |      85 |      285 |        1285 |      4285 |     9285 | 170 |  171 | DTAAAA   | TNMAAA   | HHHHxx  | 8470
+    9961 |    2058 |   1 |    1 |   1 |      1 |      61 |      961 |        1961 |      4961 |     9961 | 122 |  123 | DTAAAA   | EBDAAA   | OOOOxx  | 2059
 (16 rows)
 
 -- unknown or unspecified parameter types: should succeed
diff --git a/expected/extra/select.out b/expected/extra/select.out
index 49096f8..ae926ef 100644
--- a/expected/extra/select.out
+++ b/expected/extra/select.out
@@ -586,10 +586,11 @@ SELECT * FROM foo ORDER BY f1 DESC NULLS LAST;
 -- partial index is usable
 explain (costs off)
 select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
-      QUERY PLAN       
------------------------
+              QUERY PLAN               
+---------------------------------------
  Foreign Scan on onek2
-(1 row)
+   Filter: (stringu1 = 'ATAAAA'::name)
+(2 rows)
 
 select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
@@ -603,14 +604,16 @@ select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
                   QUERY PLAN                   
 -----------------------------------------------
  Foreign Scan on onek2 (actual rows=1 loops=1)
-(1 row)
+   Filter: (stringu1 = 'ATAAAA'::name)
+(2 rows)
 
 explain (costs off)
 select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
-      QUERY PLAN       
------------------------
+              QUERY PLAN               
+---------------------------------------
  Foreign Scan on onek2
-(1 row)
+   Filter: (stringu1 = 'ATAAAA'::name)
+(2 rows)
 
 select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
  unique2 
@@ -621,10 +624,11 @@ select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA';
 -- partial index predicate implies clause, so no need for retest
 explain (costs off)
 select * from onek2 where unique2 = 11 and stringu1 < 'B';
-      QUERY PLAN       
------------------------
+            QUERY PLAN            
+----------------------------------
  Foreign Scan on onek2
-(1 row)
+   Filter: (stringu1 < 'B'::name)
+(2 rows)
 
 select * from onek2 where unique2 = 11 and stringu1 < 'B';
  unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
@@ -634,10 +638,11 @@ select * from onek2 where unique2 = 11 and stringu1 < 'B';
 
 explain (costs off)
 select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
-      QUERY PLAN       
------------------------
+            QUERY PLAN            
+----------------------------------
  Foreign Scan on onek2
-(1 row)
+   Filter: (stringu1 < 'B'::name)
+(2 rows)
 
 select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
  unique2 
@@ -648,11 +653,12 @@ select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
 -- but if it's an update target, must retest anyway
 explain (costs off)
 select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
-         QUERY PLAN          
------------------------------
+               QUERY PLAN               
+----------------------------------------
  LockRows
    ->  Foreign Scan on onek2
-(2 rows)
+         Filter: (stringu1 < 'B'::name)
+(3 rows)
 
 select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
  unique2 
@@ -663,10 +669,11 @@ select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update;
 -- partial index is not applicable
 explain (costs off)
 select unique2 from onek2 where unique2 = 11 and stringu1 < 'C';
-      QUERY PLAN       
------------------------
+            QUERY PLAN            
+----------------------------------
  Foreign Scan on onek2
-(1 row)
+   Filter: (stringu1 < 'C'::name)
+(2 rows)
 
 select unique2 from onek2 where unique2 = 11 and stringu1 < 'C';
  unique2 
@@ -678,10 +685,11 @@ select unique2 from onek2 where unique2 = 11 and stringu1 < 'C';
 SET enable_indexscan TO off;
 explain (costs off)
 select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
-      QUERY PLAN       
------------------------
+            QUERY PLAN            
+----------------------------------
  Foreign Scan on onek2
-(1 row)
+   Filter: (stringu1 < 'B'::name)
+(2 rows)
 
 select unique2 from onek2 where unique2 = 11 and stringu1 < 'B';
  unique2 
@@ -694,10 +702,11 @@ RESET enable_indexscan;
 explain (costs off)
 select unique1, unique2 from onek2
   where (unique2 = 11 or unique1 = 0) and stringu1 < 'B';
-      QUERY PLAN       
------------------------
+            QUERY PLAN            
+----------------------------------
  Foreign Scan on onek2
-(1 row)
+   Filter: (stringu1 < 'B'::name)
+(2 rows)
 
 select unique1, unique2 from onek2
   where (unique2 = 11 or unique1 = 0) and stringu1 < 'B';
@@ -710,10 +719,11 @@ select unique1, unique2 from onek2
 explain (costs off)
 select unique1, unique2 from onek2
   where (unique2 = 11 and stringu1 < 'B') or unique1 = 0;
-      QUERY PLAN       
------------------------
+                                QUERY PLAN                                
+--------------------------------------------------------------------------
  Foreign Scan on onek2
-(1 row)
+   Filter: (((unique2 = 11) AND (stringu1 < 'B'::name)) OR (unique1 = 0))
+(2 rows)
 
 select unique1, unique2 from onek2
   where (unique2 = 11 and stringu1 < 'B') or unique1 = 0;
diff --git a/expected/extra/select_having.out b/expected/extra/select_having.out
index 521f9ed..6360aa6 100644
--- a/expected/extra/select_having.out
+++ b/expected/extra/select_having.out
@@ -26,7 +26,7 @@ SELECT b, c FROM test_having
 
 -- HAVING is effectively equivalent to WHERE in this case
 SELECT b, c FROM test_having
-	GROUP BY b, c HAVING b = 3 ORDER BY b, c;
+	GROUP BY b, c HAVING b = 3 ORDER BY b, c collate "en_US.utf8";
  b |    c     
 ---+----------
  3 | bbbb    
@@ -45,7 +45,7 @@ SELECT lower(c), count(c) FROM test_having
 
 SELECT c, max(a) FROM test_having
 	GROUP BY c HAVING count(*) > 2 OR min(a) = max(a)
-	ORDER BY c;
+	ORDER BY c collate "en_US.utf8";
     c     | max 
 ----------+-----
  bbbb     |   5
diff --git a/expected/extra/sqlite_fdw_post.out b/expected/extra/sqlite_fdw_post.out
index c4b98c4..f26220a 100644
--- a/expected/extra/sqlite_fdw_post.out
+++ b/expected/extra/sqlite_fdw_post.out
@@ -111,7 +111,7 @@ SELECT c3, c4 FROM ft1 ORDER BY c3, c1 LIMIT 1;  -- should work
 
 ALTER SERVER sqlite_svr OPTIONS (SET database 'no such database');
 SELECT c3, c4 FROM ft1 ORDER BY c3, c1 LIMIT 1;  -- should fail
-ERROR:  SQL error during prepare: no such table: main.T 1 SELECT `C 1`, `c3`, `c4` FROM main."T 1"
+ERROR:  SQL error during prepare: no such table: main.T 1 SELECT `C 1`, `c3`, `c4` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST LIMIT 1
 DO $d$
     BEGIN
         EXECUTE $$ALTER SERVER sqlite_svr
@@ -130,13 +130,10 @@ SELECT c3, c4 FROM ft1 ORDER BY c3, c1 LIMIT 1;  -- should work again
 -- ===================================================================
 -- single table without alias
 EXPLAIN (COSTS OFF) SELECT * FROM ft1 ORDER BY c3, c1 OFFSET 100 LIMIT 10;
-           QUERY PLAN            
----------------------------------
- Limit
-   ->  Sort
-         Sort Key: c3, c1
-         ->  Foreign Scan on ft1
-(4 rows)
+     QUERY PLAN      
+---------------------
+ Foreign Scan on ft1
+(1 row)
 
 SELECT * FROM ft1 ORDER BY c3, c1 OFFSET 100 LIMIT 10;
  c1  | c2 |  c3   |              c4              |            c5            | c6 |     c7     | c8  
@@ -184,17 +181,12 @@ SELECT * FROM ft1 t1 ORDER BY t1.c3, t1.c1, t1.tableoid OFFSET 100 LIMIT 10;
 
 -- whole-row reference
 EXPLAIN (VERBOSE, COSTS OFF) SELECT t1 FROM ft1 t1 ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
-                                             QUERY PLAN                                             
-----------------------------------------------------------------------------------------------------
- Limit
+                                                                          QUERY PLAN                                                                           
+---------------------------------------------------------------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.ft1 t1
    Output: t1.*, c3, c1
-   ->  Sort
-         Output: t1.*, c3, c1
-         Sort Key: t1.c3, t1.c1
-         ->  Foreign Scan on public.ft1 t1
-               Output: t1.*, c3, c1
-               SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(8 rows)
+   SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST LIMIT 10 OFFSET 100
+(3 rows)
 
 SELECT t1 FROM ft1 t1 ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
                                              t1                                             
@@ -964,31 +956,22 @@ SELECT count(c3) FROM ft1 t1 WHERE t1.c1 === t1.c2;
 -- join two tables
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
+                                                    QUERY PLAN                                                     
+-------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1.c1, t2.c1, t1.c3
-   ->  Sort
+   ->  Nested Loop
          Output: t1.c1, t2.c1, t1.c3
-         Sort Key: t1.c3, t1.c1
-         ->  Merge Join
-               Output: t1.c1, t2.c1, t1.c3
-               Merge Cond: (t1.c1 = t2.c1)
-               ->  Sort
-                     Output: t1.c1, t1.c3
-                     Sort Key: t1.c1
-                     ->  Foreign Scan on public.ft1 t1
-                           Output: t1.c1, t1.c3
-                           SQLite query: SELECT `C 1`, `c3` FROM main."T 1"
-               ->  Materialize
+         Join Filter: (t1.c1 = t2.c1)
+         ->  Foreign Scan on public.ft1 t1
+               Output: t1.c1, t1.c3
+               SQLite query: SELECT `C 1`, `c3` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+         ->  Materialize
+               Output: t2.c1
+               ->  Foreign Scan on public.ft2 t2
                      Output: t2.c1
-                     ->  Sort
-                           Output: t2.c1
-                           Sort Key: t2.c1
-                           ->  Foreign Scan on public.ft2 t2
-                                 Output: t2.c1
-                                 SQLite query: SELECT `C 1` FROM main."T 1"
-(22 rows)
+                     SQLite query: SELECT `C 1` FROM main."T 1"
+(13 rows)
 
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
  c1  | c1  
@@ -1008,42 +991,30 @@ SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t
 -- join three tables
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1, t2.c2, t3.c3 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) JOIN ft4 t3 ON (t3.c1 = t1.c1) ORDER BY t1.c3, t1.c1 OFFSET 10 LIMIT 10;
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
+                                                       QUERY PLAN                                                        
+-------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1.c1, t2.c2, t3.c3, t1.c3
-   ->  Sort
+   ->  Nested Loop
          Output: t1.c1, t2.c2, t3.c3, t1.c3
-         Sort Key: t1.c3, t1.c1
-         ->  Merge Join
-               Output: t1.c1, t2.c2, t3.c3, t1.c3
-               Merge Cond: (t3.c1 = t1.c1)
-               ->  Sort
+         Join Filter: (t1.c1 = t2.c1)
+         ->  Nested Loop
+               Output: t1.c1, t1.c3, t3.c3, t3.c1
+               Join Filter: (t1.c1 = t3.c1)
+               ->  Foreign Scan on public.ft1 t1
+                     Output: t1.c1, t1.c3
+                     SQLite query: SELECT `C 1`, `c3` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+               ->  Materialize
                      Output: t3.c3, t3.c1
-                     Sort Key: t3.c1
                      ->  Foreign Scan on public.ft4 t3
                            Output: t3.c3, t3.c1
                            SQLite query: SELECT `c1`, `c3` FROM main."T 3"
-               ->  Materialize
-                     Output: t1.c1, t1.c3, t2.c2, t2.c1
-                     ->  Merge Join
-                           Output: t1.c1, t1.c3, t2.c2, t2.c1
-                           Merge Cond: (t1.c1 = t2.c1)
-                           ->  Sort
-                                 Output: t1.c1, t1.c3
-                                 Sort Key: t1.c1
-                                 ->  Foreign Scan on public.ft1 t1
-                                       Output: t1.c1, t1.c3
-                                       SQLite query: SELECT `C 1`, `c3` FROM main."T 1"
-                           ->  Materialize
-                                 Output: t2.c2, t2.c1
-                                 ->  Sort
-                                       Output: t2.c2, t2.c1
-                                       Sort Key: t2.c1
-                                       ->  Foreign Scan on public.ft2 t2
-                                             Output: t2.c2, t2.c1
-                                             SQLite query: SELECT `C 1`, `c2` FROM main."T 1"
-(33 rows)
+         ->  Materialize
+               Output: t2.c2, t2.c1
+               ->  Foreign Scan on public.ft2 t2
+                     Output: t2.c2, t2.c1
+                     SQLite query: SELECT `C 1`, `c2` FROM main."T 1"
+(21 rows)
 
 SELECT t1.c1, t2.c2, t3.c3 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) JOIN ft4 t3 ON (t3.c1 = t1.c1) ORDER BY t1.c3, t1.c1 OFFSET 10 LIMIT 10;
  c1 | c2 |   c3   
@@ -1987,33 +1958,24 @@ SELECT t1.c1, t2.c1 FROM ft4 t1 FULL JOIN ft5 t2 ON (t1.c1 = t2.c1) WHERE (t1.c1
 -- tests whole-row reference for row marks
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10 FOR UPDATE OF t1;
-                                                         QUERY PLAN                                                         
-----------------------------------------------------------------------------------------------------------------------------
+                                                                         QUERY PLAN                                                                          
+-------------------------------------------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
    ->  LockRows
          Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-         ->  Sort
+         ->  Nested Loop
                Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-               Sort Key: t1.c3, t1.c1
-               ->  Merge Join
-                     Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-                     Merge Cond: (t1.c1 = t2.c1)
-                     ->  Sort
-                           Output: t1.c1, t1.c3, t1.*
-                           Sort Key: t1.c1
-                           ->  Foreign Scan on public.ft1 t1
-                                 Output: t1.c1, t1.c3, t1.*
-                                 SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-                     ->  Materialize
+               Join Filter: (t1.c1 = t2.c1)
+               ->  Foreign Scan on public.ft1 t1
+                     Output: t1.c1, t1.c3, t1.*
+                     SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+               ->  Materialize
+                     Output: t2.c1, t2.*
+                     ->  Foreign Scan on public.ft2 t2
                            Output: t2.c1, t2.*
-                           ->  Sort
-                                 Output: t2.c1, t2.*
-                                 Sort Key: t2.c1
-                                 ->  Foreign Scan on public.ft2 t2
-                                       Output: t2.c1, t2.*
-                                       SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(24 rows)
+                           SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
+(15 rows)
 
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10 FOR UPDATE OF t1;
  c1  | c1  
@@ -2032,33 +1994,24 @@ SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t
 
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10 FOR UPDATE;
-                                                         QUERY PLAN                                                         
-----------------------------------------------------------------------------------------------------------------------------
+                                                                         QUERY PLAN                                                                          
+-------------------------------------------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
    ->  LockRows
          Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-         ->  Sort
+         ->  Nested Loop
                Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-               Sort Key: t1.c3, t1.c1
-               ->  Merge Join
-                     Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-                     Merge Cond: (t1.c1 = t2.c1)
-                     ->  Sort
-                           Output: t1.c1, t1.c3, t1.*
-                           Sort Key: t1.c1
-                           ->  Foreign Scan on public.ft1 t1
-                                 Output: t1.c1, t1.c3, t1.*
-                                 SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-                     ->  Materialize
+               Join Filter: (t1.c1 = t2.c1)
+               ->  Foreign Scan on public.ft1 t1
+                     Output: t1.c1, t1.c3, t1.*
+                     SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+               ->  Materialize
+                     Output: t2.c1, t2.*
+                     ->  Foreign Scan on public.ft2 t2
                            Output: t2.c1, t2.*
-                           ->  Sort
-                                 Output: t2.c1, t2.*
-                                 Sort Key: t2.c1
-                                 ->  Foreign Scan on public.ft2 t2
-                                       Output: t2.c1, t2.*
-                                       SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(24 rows)
+                           SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
+(15 rows)
 
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10 FOR UPDATE;
  c1  | c1  
@@ -2078,33 +2031,24 @@ SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t
 -- join two tables with FOR SHARE clause
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10 FOR SHARE OF t1;
-                                                         QUERY PLAN                                                         
-----------------------------------------------------------------------------------------------------------------------------
+                                                                         QUERY PLAN                                                                          
+-------------------------------------------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
    ->  LockRows
          Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-         ->  Sort
+         ->  Nested Loop
                Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-               Sort Key: t1.c3, t1.c1
-               ->  Merge Join
-                     Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-                     Merge Cond: (t1.c1 = t2.c1)
-                     ->  Sort
-                           Output: t1.c1, t1.c3, t1.*
-                           Sort Key: t1.c1
-                           ->  Foreign Scan on public.ft1 t1
-                                 Output: t1.c1, t1.c3, t1.*
-                                 SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-                     ->  Materialize
+               Join Filter: (t1.c1 = t2.c1)
+               ->  Foreign Scan on public.ft1 t1
+                     Output: t1.c1, t1.c3, t1.*
+                     SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+               ->  Materialize
+                     Output: t2.c1, t2.*
+                     ->  Foreign Scan on public.ft2 t2
                            Output: t2.c1, t2.*
-                           ->  Sort
-                                 Output: t2.c1, t2.*
-                                 Sort Key: t2.c1
-                                 ->  Foreign Scan on public.ft2 t2
-                                       Output: t2.c1, t2.*
-                                       SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(24 rows)
+                           SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
+(15 rows)
 
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10 FOR SHARE OF t1;
  c1  | c1  
@@ -2123,33 +2067,24 @@ SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t
 
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10 FOR SHARE;
-                                                         QUERY PLAN                                                         
-----------------------------------------------------------------------------------------------------------------------------
+                                                                         QUERY PLAN                                                                          
+-------------------------------------------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
    ->  LockRows
          Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-         ->  Sort
+         ->  Nested Loop
                Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-               Sort Key: t1.c3, t1.c1
-               ->  Merge Join
-                     Output: t1.c1, t2.c1, t1.c3, t1.*, t2.*
-                     Merge Cond: (t1.c1 = t2.c1)
-                     ->  Sort
-                           Output: t1.c1, t1.c3, t1.*
-                           Sort Key: t1.c1
-                           ->  Foreign Scan on public.ft1 t1
-                                 Output: t1.c1, t1.c3, t1.*
-                                 SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-                     ->  Materialize
+               Join Filter: (t1.c1 = t2.c1)
+               ->  Foreign Scan on public.ft1 t1
+                     Output: t1.c1, t1.c3, t1.*
+                     SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+               ->  Materialize
+                     Output: t2.c1, t2.*
+                     ->  Foreign Scan on public.ft2 t2
                            Output: t2.c1, t2.*
-                           ->  Sort
-                                 Output: t2.c1, t2.*
-                                 Sort Key: t2.c1
-                                 ->  Foreign Scan on public.ft2 t2
-                                       Output: t2.c1, t2.*
-                                       SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(24 rows)
+                           SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
+(15 rows)
 
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10 FOR SHARE;
  c1  | c1  
@@ -2169,34 +2104,22 @@ SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t
 -- join in CTE
 EXPLAIN (VERBOSE, COSTS OFF)
 WITH t (c1_1, c1_3, c2_1) AS (SELECT t1.c1, t1.c3, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1)) SELECT c1_1, c2_1 FROM t ORDER BY c1_3, c1_1 OFFSET 100 LIMIT 10;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
+                                                    QUERY PLAN                                                     
+-------------------------------------------------------------------------------------------------------------------
  Limit
-   Output: t.c1_1, t.c2_1, t.c1_3
-   CTE t
-     ->  Merge Join
-           Output: t1.c1, t1.c3, t2.c1
-           Merge Cond: (t1.c1 = t2.c1)
-           ->  Sort
-                 Output: t1.c1, t1.c3
-                 Sort Key: t1.c1
-                 ->  Foreign Scan on public.ft1 t1
-                       Output: t1.c1, t1.c3
-                       SQLite query: SELECT `C 1`, `c3` FROM main."T 1"
-           ->  Materialize
-                 Output: t2.c1
-                 ->  Sort
-                       Output: t2.c1
-                       Sort Key: t2.c1
-                       ->  Foreign Scan on public.ft2 t2
-                             Output: t2.c1
-                             SQLite query: SELECT `C 1` FROM main."T 1"
-   ->  Sort
-         Output: t.c1_1, t.c2_1, t.c1_3
-         Sort Key: t.c1_3, t.c1_1
-         ->  CTE Scan on t
-               Output: t.c1_1, t.c2_1, t.c1_3
-(25 rows)
+   Output: t1.c1, t2.c1, t1.c3
+   ->  Nested Loop
+         Output: t1.c1, t2.c1, t1.c3
+         Join Filter: (t1.c1 = t2.c1)
+         ->  Foreign Scan on public.ft1 t1
+               Output: t1.c1, t1.c3
+               SQLite query: SELECT `C 1`, `c3` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+         ->  Materialize
+               Output: t2.c1
+               ->  Foreign Scan on public.ft2 t2
+                     Output: t2.c1
+                     SQLite query: SELECT `C 1` FROM main."T 1"
+(13 rows)
 
 WITH t (c1_1, c1_3, c2_1) AS (SELECT t1.c1, t1.c3, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1)) SELECT c1_1, c2_1 FROM t ORDER BY c1_3, c1_1 OFFSET 100 LIMIT 10;
  c1_1 | c2_1 
@@ -2216,58 +2139,40 @@ WITH t (c1_1, c1_3, c2_1) AS (SELECT t1.c1, t1.c3, t2.c1 FROM ft1 t1 JOIN ft2 t2
 -- ctid with whole-row reference
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.ctid, t1, t2, t1.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
-                                                      QUERY PLAN                                                      
-----------------------------------------------------------------------------------------------------------------------
+                                                                      QUERY PLAN                                                                       
+-------------------------------------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1.ctid, t1.*, t2.*, t1.c1, t1.c3
-   ->  Sort
+   ->  Nested Loop
          Output: t1.ctid, t1.*, t2.*, t1.c1, t1.c3
-         Sort Key: t1.c3, t1.c1
-         ->  Merge Join
-               Output: t1.ctid, t1.*, t2.*, t1.c1, t1.c3
-               Merge Cond: (t1.c1 = t2.c1)
-               ->  Sort
-                     Output: t1.ctid, t1.*, t1.c1, t1.c3
-                     Sort Key: t1.c1
-                     ->  Foreign Scan on public.ft1 t1
-                           Output: t1.ctid, t1.*, t1.c1, t1.c3
-                           SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-               ->  Materialize
+         Join Filter: (t1.c1 = t2.c1)
+         ->  Foreign Scan on public.ft1 t1
+               Output: t1.ctid, t1.*, t1.c1, t1.c3
+               SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+         ->  Materialize
+               Output: t2.*, t2.c1
+               ->  Foreign Scan on public.ft2 t2
                      Output: t2.*, t2.c1
-                     ->  Sort
-                           Output: t2.*, t2.c1
-                           Sort Key: t2.c1
-                           ->  Foreign Scan on public.ft2 t2
-                                 Output: t2.*, t2.c1
-                                 SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(22 rows)
+                     SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
+(13 rows)
 
 -- SEMI JOIN, not pushed down
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1 FROM ft1 t1 WHERE EXISTS (SELECT 1 FROM ft2 t2 WHERE t1.c1 = t2.c1) ORDER BY t1.c1 OFFSET 100 LIMIT 10;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
+                                       QUERY PLAN                                       
+----------------------------------------------------------------------------------------
  Limit
    Output: t1.c1
-   ->  Sort
+   ->  Merge Semi Join
          Output: t1.c1
-         Sort Key: t1.c1
-         ->  Hash Join
+         Merge Cond: (t1.c1 = t2.c1)
+         ->  Foreign Scan on public.ft1 t1
                Output: t1.c1
-               Inner Unique: true
-               Hash Cond: (t1.c1 = t2.c1)
-               ->  Foreign Scan on public.ft1 t1
-                     Output: t1.c1
-                     SQLite query: SELECT `C 1` FROM main."T 1"
-               ->  Hash
-                     Output: t2.c1
-                     ->  HashAggregate
-                           Output: t2.c1
-                           Group Key: t2.c1
-                           ->  Foreign Scan on public.ft2 t2
-                                 Output: t2.c1
-                                 SQLite query: SELECT `C 1` FROM main."T 1"
-(20 rows)
+               SQLite query: SELECT `C 1` FROM main."T 1" ORDER BY `C 1` ASC NULLS LAST
+         ->  Foreign Scan on public.ft2 t2
+               Output: t2.c1
+               SQLite query: SELECT `C 1` FROM main."T 1" ORDER BY `C 1` ASC NULLS LAST
+(11 rows)
 
 SELECT t1.c1 FROM ft1 t1 WHERE EXISTS (SELECT 1 FROM ft2 t2 WHERE t1.c1 = t2.c1) ORDER BY t1.c1 OFFSET 100 LIMIT 10;
  c1  
@@ -2287,25 +2192,22 @@ SELECT t1.c1 FROM ft1 t1 WHERE EXISTS (SELECT 1 FROM ft2 t2 WHERE t1.c1 = t2.c1)
 -- ANTI JOIN, not pushed down
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1 FROM ft1 t1 WHERE NOT EXISTS (SELECT 1 FROM ft2 t2 WHERE t1.c1 = t2.c2) ORDER BY t1.c1 OFFSET 100 LIMIT 10;
-                             QUERY PLAN                              
----------------------------------------------------------------------
+                                       QUERY PLAN                                       
+----------------------------------------------------------------------------------------
  Limit
    Output: t1.c1
-   ->  Sort
+   ->  Nested Loop Anti Join
          Output: t1.c1
-         Sort Key: t1.c1
-         ->  Hash Anti Join
+         Join Filter: (t1.c1 = t2.c2)
+         ->  Foreign Scan on public.ft1 t1
                Output: t1.c1
-               Hash Cond: (t1.c1 = t2.c2)
-               ->  Foreign Scan on public.ft1 t1
-                     Output: t1.c1
-                     SQLite query: SELECT `C 1` FROM main."T 1"
-               ->  Hash
+               SQLite query: SELECT `C 1` FROM main."T 1" ORDER BY `C 1` ASC NULLS LAST
+         ->  Materialize
+               Output: t2.c2
+               ->  Foreign Scan on public.ft2 t2
                      Output: t2.c2
-                     ->  Foreign Scan on public.ft2 t2
-                           Output: t2.c2
-                           SQLite query: SELECT `c2` FROM main."T 1"
-(16 rows)
+                     SQLite query: SELECT `c2` FROM main."T 1"
+(13 rows)
 
 SELECT t1.c1 FROM ft1 t1 WHERE NOT EXISTS (SELECT 1 FROM ft2 t2 WHERE t1.c1 = t2.c2) ORDER BY t1.c1 OFFSET 100 LIMIT 10;
  c1  
@@ -2362,28 +2264,22 @@ SELECT t1.c1, t2.c1 FROM ft1 t1 CROSS JOIN ft2 t2 ORDER BY t1.c1, t2.c1 OFFSET 1
 -- different server, not pushed down. No result expected.
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1, t2.c1 FROM ft5 t1 JOIN ft6 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c1, t2.c1 OFFSET 100 LIMIT 10;
-                             QUERY PLAN                              
----------------------------------------------------------------------
+                                         QUERY PLAN                                         
+--------------------------------------------------------------------------------------------
  Limit
    Output: t1.c1, t2.c1
    ->  Merge Join
          Output: t1.c1, t2.c1
          Merge Cond: (t1.c1 = t2.c1)
-         ->  Sort
-               Output: t1.c1
-               Sort Key: t1.c1
-               ->  Foreign Scan on public.ft5 t1
-                     Output: t1.c1
-                     SQLite query: SELECT `c1` FROM main."T 4"
+         ->  Foreign Scan on public.ft5 t1
+               Output: t1.c1, t1.c2, t1.c3
+               SQLite query: SELECT `c1` FROM main."T 4" ORDER BY `c1` ASC NULLS LAST
          ->  Materialize
-               Output: t2.c1
-               ->  Sort
-                     Output: t2.c1
-                     Sort Key: t2.c1
-                     ->  Foreign Scan on public.ft6 t2
-                           Output: t2.c1
-                           SQLite query: SELECT `c1` FROM main."T 4"
-(19 rows)
+               Output: t2.c1, t2.c2, t2.c3
+               ->  Foreign Scan on public.ft6 t2
+                     Output: t2.c1, t2.c2, t2.c3
+                     SQLite query: SELECT `c1` FROM main."T 4" ORDER BY `c1` ASC NULLS LAST
+(13 rows)
 
 SELECT t1.c1, t2.c1 FROM ft5 t1 JOIN ft6 t2 ON (t1.c1 = t2.c1) ORDER BY t1.c1, t2.c1 OFFSET 100 LIMIT 10;
  c1 | c1 
@@ -2438,31 +2334,22 @@ SELECT t1.c1, t2.c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON (t1.c8 = t2.c8) ORDER BY t1.
 -- unsafe conditions on one side (c8 has a UDT), not pushed down.
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1, t2.c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON (t1.c1 = t2.c1) WHERE t1.c8 = 'foo' ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
-                                            QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
+                                                                QUERY PLAN                                                                
+------------------------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1.c1, t2.c1, t1.c3
-   ->  Sort
+   ->  Nested Loop Left Join
          Output: t1.c1, t2.c1, t1.c3
-         Sort Key: t1.c3, t1.c1
-         ->  Merge Left Join
-               Output: t1.c1, t2.c1, t1.c3
-               Merge Cond: (t1.c1 = t2.c1)
-               ->  Sort
-                     Output: t1.c1, t1.c3
-                     Sort Key: t1.c1
-                     ->  Foreign Scan on public.ft1 t1
-                           Output: t1.c1, t1.c3
-                           SQLite query: SELECT `C 1`, `c3` FROM main."T 1" WHERE ((`c8` = 'foo'))
-               ->  Materialize
+         Join Filter: (t1.c1 = t2.c1)
+         ->  Foreign Scan on public.ft1 t1
+               Output: t1.c1, t1.c3
+               SQLite query: SELECT `C 1`, `c3` FROM main."T 1" WHERE ((`c8` = 'foo')) ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+         ->  Materialize
+               Output: t2.c1
+               ->  Foreign Scan on public.ft2 t2
                      Output: t2.c1
-                     ->  Sort
-                           Output: t2.c1
-                           Sort Key: t2.c1
-                           ->  Foreign Scan on public.ft2 t2
-                                 Output: t2.c1
-                                 SQLite query: SELECT `C 1` FROM main."T 1"
-(22 rows)
+                     SQLite query: SELECT `C 1` FROM main."T 1"
+(13 rows)
 
 SELECT t1.c1, t2.c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON (t1.c1 = t2.c1) WHERE t1.c8 = 'foo' ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
  c1  | c1  
@@ -2485,31 +2372,22 @@ SELECT t1.c1, t2.c1 FROM ft1 t1 LEFT JOIN ft2 t2 ON (t1.c1 = t2.c1) WHERE t1.c8
 -- into one of the joining sides.
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) WHERE t1.c8 = t2.c8 ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
-                                    QUERY PLAN                                    
-----------------------------------------------------------------------------------
+                                                       QUERY PLAN                                                        
+-------------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1.c1, t2.c1, t1.c3
-   ->  Sort
+   ->  Nested Loop
          Output: t1.c1, t2.c1, t1.c3
-         Sort Key: t1.c3, t1.c1
-         ->  Merge Join
-               Output: t1.c1, t2.c1, t1.c3
-               Merge Cond: ((t1.c1 = t2.c1) AND (t1.c8 = t2.c8))
-               ->  Sort
-                     Output: t1.c1, t1.c3, t1.c8
-                     Sort Key: t1.c1, t1.c8
-                     ->  Foreign Scan on public.ft1 t1
-                           Output: t1.c1, t1.c3, t1.c8
-                           SQLite query: SELECT `C 1`, `c3`, `c8` FROM main."T 1"
-               ->  Materialize
+         Join Filter: ((t1.c1 = t2.c1) AND (t1.c8 = t2.c8))
+         ->  Foreign Scan on public.ft1 t1
+               Output: t1.c1, t1.c3, t1.c8
+               SQLite query: SELECT `C 1`, `c3`, `c8` FROM main."T 1" ORDER BY `c3` ASC NULLS LAST, `C 1` ASC NULLS LAST
+         ->  Materialize
+               Output: t2.c1, t2.c8
+               ->  Foreign Scan on public.ft2 t2
                      Output: t2.c1, t2.c8
-                     ->  Sort
-                           Output: t2.c1, t2.c8
-                           Sort Key: t2.c1, t2.c8
-                           ->  Foreign Scan on public.ft2 t2
-                                 Output: t2.c1, t2.c8
-                                 SQLite query: SELECT `C 1`, `c8` FROM main."T 1"
-(22 rows)
+                     SQLite query: SELECT `C 1`, `c8` FROM main."T 1"
+(13 rows)
 
 SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2 ON (t1.c1 = t2.c1) WHERE t1.c8 = t2.c8 ORDER BY t1.c3, t1.c1 OFFSET 100 LIMIT 10;
  c1  | c1  
@@ -2596,38 +2474,29 @@ SELECT t1c1, avg(t1c1 + t2c1) FROM (SELECT t1.c1, t2.c1 FROM ft1 t1 JOIN ft2 t2
 -- join with lateral reference
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT t1."C 1" FROM "S 1"."T 1" t1, LATERAL (SELECT DISTINCT t2.c1, t3.c1 FROM ft1 t2, ft2 t3 WHERE t2.c1 = t3.c1 AND t2.c2 = t1.c2) q ORDER BY t1."C 1" OFFSET 10 LIMIT 10;
-                                             QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
+                                                      QUERY PLAN                                                       
+-----------------------------------------------------------------------------------------------------------------------
  Limit
    Output: t1."C 1"
-   ->  Sort
+   ->  Nested Loop
          Output: t1."C 1"
-         Sort Key: t1."C 1"
-         ->  Nested Loop
-               Output: t1."C 1"
-               ->  Foreign Scan on "S 1"."T 1" t1
-                     Output: t1."C 1", t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
-                     SQLite query: SELECT `C 1`, `c2` FROM main."T 1"
-               ->  Unique
+         ->  Foreign Scan on "S 1"."T 1" t1
+               Output: t1."C 1", t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
+               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" ORDER BY `C 1` ASC NULLS LAST
+         ->  Unique
+               Output: t2.c1, t3.c1
+               ->  Merge Join
                      Output: t2.c1, t3.c1
-                     ->  Merge Join
-                           Output: t2.c1, t3.c1
-                           Merge Cond: (t2.c1 = t3.c1)
-                           ->  Sort
-                                 Output: t2.c1
-                                 Sort Key: t2.c1
-                                 ->  Foreign Scan on public.ft1 t2
-                                       Output: t2.c1
-                                       SQLite query: SELECT `C 1` FROM main."T 1" WHERE ((`c2` = ?))
-                           ->  Materialize
+                     Merge Cond: (t2.c1 = t3.c1)
+                     ->  Foreign Scan on public.ft1 t2
+                           Output: t2.c1
+                           SQLite query: SELECT `C 1` FROM main."T 1" WHERE ((`c2` = ?)) ORDER BY `C 1` ASC NULLS LAST
+                     ->  Materialize
+                           Output: t3.c1
+                           ->  Foreign Scan on public.ft2 t3
                                  Output: t3.c1
-                                 ->  Sort
-                                       Output: t3.c1
-                                       Sort Key: t3.c1
-                                       ->  Foreign Scan on public.ft2 t3
-                                             Output: t3.c1
-                                             SQLite query: SELECT `C 1` FROM main."T 1"
-(29 rows)
+                                 SQLite query: SELECT `C 1` FROM main."T 1" ORDER BY `C 1` ASC NULLS LAST
+(20 rows)
 
 SELECT t1."C 1" FROM "S 1"."T 1" t1, LATERAL (SELECT DISTINCT t2.c1, t3.c1 FROM ft1 t2, ft2 t3 WHERE t2.c1 = t3.c1 AND t2.c2 = t1.c2) q ORDER BY t1."C 1" OFFSET 10 LIMIT 10;
  C 1 
@@ -2718,26 +2587,20 @@ SELECT ft4.c1, q.* FROM ft4 LEFT JOIN (SELECT 13, ft1.c1, ft2.c1 FROM ft1 RIGHT
 UPDATE ft5 SET c3 = null where c1 % 9 = 0;
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT ft5, ft5.c1, ft5.c2, ft5.c3, ft4.c1, ft4.c2 FROM ft5 left join ft4 on ft5.c1 = ft4.c1 WHERE ft4.c1 BETWEEN 10 and 30 ORDER BY ft5.c1, ft4.c1;
-                                                 QUERY PLAN                                                  
--------------------------------------------------------------------------------------------------------------
+                                                             QUERY PLAN                                                             
+------------------------------------------------------------------------------------------------------------------------------------
  Merge Join
    Output: ft5.*, ft5.c1, ft5.c2, ft5.c3, ft4.c1, ft4.c2
    Merge Cond: (ft5.c1 = ft4.c1)
-   ->  Sort
+   ->  Foreign Scan on public.ft5
          Output: ft5.*, ft5.c1, ft5.c2, ft5.c3
-         Sort Key: ft5.c1
-         ->  Foreign Scan on public.ft5
-               Output: ft5.*, ft5.c1, ft5.c2, ft5.c3
-               SQLite query: SELECT `c1`, `c2`, `c3` FROM main."T 4"
+         SQLite query: SELECT `c1`, `c2`, `c3` FROM main."T 4" ORDER BY `c1` ASC NULLS LAST
    ->  Materialize
-         Output: ft4.c1, ft4.c2
-         ->  Sort
-               Output: ft4.c1, ft4.c2
-               Sort Key: ft4.c1
-               ->  Foreign Scan on public.ft4
-                     Output: ft4.c1, ft4.c2
-                     SQLite query: SELECT `c1`, `c2` FROM main."T 3" WHERE ((`c1` >= 10)) AND ((`c1` <= 30))
-(17 rows)
+         Output: ft4.c1, ft4.c2, ft4.c3
+         ->  Foreign Scan on public.ft4
+               Output: ft4.c1, ft4.c2, ft4.c3
+               SQLite query: SELECT `c1`, `c2` FROM main."T 3" WHERE ((`c1` >= 10)) AND ((`c1` <= 30)) ORDER BY `c1` ASC NULLS LAST
+(11 rows)
 
 SELECT ft5, ft5.c1, ft5.c2, ft5.c3, ft4.c1, ft4.c2 FROM ft5 left join ft4 on ft5.c1 = ft4.c1 WHERE ft4.c1 BETWEEN 10 and 30 ORDER BY ft5.c1, ft4.c1;
       ft5       | c1 | c2 |   c3   | c1 | c2 
@@ -3020,12 +2883,12 @@ select count(c6), sum(c1), avg(c1), min(c2), max(c1), stddev(c2), sum(c1) * (ran
    ->  Sort
          Output: (count(c6)), (sum(c1)), (avg(c1)), (min(c2)), (max(c1)), (stddev(c2)), c2
          Sort Key: (count(ft1.c6)), (sum(ft1.c1))
-         ->  HashAggregate
+         ->  GroupAggregate
                Output: count(c6), sum(c1), avg(c1), min(c2), max(c1), stddev(c2), c2
                Group Key: ft1.c2
                ->  Foreign Scan on public.ft1
                      Output: c6, c1, c2
-                     SQLite query: SELECT `C 1`, `c2`, `c6` FROM main."T 1" WHERE ((`c2` < 5))
+                     SQLite query: SELECT `C 1`, `c2`, `c6` FROM main."T 1" WHERE ((`c2` < 5)) ORDER BY `c2` ASC NULLS LAST
 (11 rows)
 
 select count(c6), sum(c1), avg(c1), min(c2), max(c1), stddev(c2), sum(c1) * (random() <= 1)::int as sum2 from ft1 where c2 < 5 group by c2 order by 1, 2;
@@ -3105,15 +2968,12 @@ select sum(t1.c1), count(t2.c1) from ft1 t1 inner join ft2 t2 on (t1.c1 = t2.c1)
 -- GROUP BY clause having expressions
 explain (verbose, costs off)
 select c2/2, sum(c2) * (c2/2) from ft1 group by c2/2 order by c2/2;
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
- Sort
+                                                        QUERY PLAN                                                         
+---------------------------------------------------------------------------------------------------------------------------
+ Foreign Scan
    Output: ((c2 / 2)), ((sum(c2) * (c2 / 2)))
-   Sort Key: ((ft1.c2 / 2))
-   ->  Foreign Scan
-         Output: ((c2 / 2)), ((sum(c2) * (c2 / 2)))
-         SQLite query: SELECT (`c2` / 2), (sum(`c2`) * (`c2` / 2)) FROM main."T 1" GROUP BY 1
-(6 rows)
+   SQLite query: SELECT (`c2` / 2), (sum(`c2`) * (`c2` / 2)) FROM main."T 1" GROUP BY 1 ORDER BY (`c2` / 2) ASC NULLS LAST
+(3 rows)
 
 select c2/2, sum(c2) * (c2/2) from ft1 group by c2/2 order by c2/2;
  ?column? | ?column? 
@@ -3197,15 +3057,12 @@ select c2 * (random() <= 1)::int as c2 from ft2 group by c2 * (random() <= 1)::i
 -- Also, ORDER BY contains an aggregate function
 explain (verbose, costs off)
 select c2, c2 from ft1 where c2 > 6 group by 1, 2 order by sum(c1);
-                                              QUERY PLAN                                              
-------------------------------------------------------------------------------------------------------
- Sort
+                                                            QUERY PLAN                                                             
+-----------------------------------------------------------------------------------------------------------------------------------
+ Foreign Scan
    Output: c2, c2, (sum(c1))
-   Sort Key: (sum(ft1.c1))
-   ->  Foreign Scan
-         Output: c2, c2, (sum(c1))
-         SQLite query: SELECT `c2`, `c2`, sum(`C 1`) FROM main."T 1" WHERE ((`c2` > 6)) GROUP BY 1, 2
-(6 rows)
+   SQLite query: SELECT `c2`, `c2`, sum(`C 1`) FROM main."T 1" WHERE ((`c2` > 6)) GROUP BY 1, 2 ORDER BY sum(`C 1`) ASC NULLS LAST
+(3 rows)
 
 select c2, c2 from ft1 where c2 > 6 group by 1, 2 order by sum(c1);
  c2 | c2 
@@ -3218,15 +3075,12 @@ select c2, c2 from ft1 where c2 > 6 group by 1, 2 order by sum(c1);
 -- Testing HAVING clause shippability
 explain (verbose, costs off)
 select c2, sum(c1) from ft2 group by c2 having avg(c1) < 500 and sum(c1) < 49800 order by c2;
-                                                           QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
- Sort
+                                                                       QUERY PLAN                                                                       
+--------------------------------------------------------------------------------------------------------------------------------------------------------
+ Foreign Scan
    Output: c2, (sum(c1))
-   Sort Key: ft2.c2
-   ->  Foreign Scan
-         Output: c2, (sum(c1))
-         SQLite query: SELECT `c2`, sum(`C 1`) FROM main."T 1" GROUP BY 1 HAVING ((avg(`C 1`) < 500)) AND ((sum(`C 1`) < 49800))
-(6 rows)
+   SQLite query: SELECT `c2`, sum(`C 1`) FROM main."T 1" GROUP BY 1 HAVING ((avg(`C 1`) < 500)) AND ((sum(`C 1`) < 49800)) ORDER BY `c2` ASC NULLS LAST
+(3 rows)
 
 select c2, sum(c1) from ft2 group by c2 having avg(c1) < 500 and sum(c1) < 49800 order by c2;
  c2 |  sum  
@@ -3268,34 +3122,31 @@ select sum(c1) from ft1 group by c2 having avg(c1 * (random() <= 1)::int) > 100
  Sort
    Output: (sum(c1)), c2
    Sort Key: (sum(ft1.c1))
-   ->  HashAggregate
+   ->  GroupAggregate
          Output: sum(c1), c2
          Group Key: ft1.c2
          Filter: (avg((ft1.c1 * ((random() <= '1'::double precision))::integer)) > '100'::numeric)
          ->  Foreign Scan on public.ft1
                Output: c1, c2
-               SQLite query: SELECT `C 1`, `c2` FROM main."T 1"
+               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" ORDER BY `c2` ASC NULLS LAST
 (10 rows)
 
 -- Testing ORDER BY, DISTINCT, FILTER, Ordered-sets and VARIADIC within aggregates
 -- ORDER BY within aggregate, same column used to order
 explain (verbose, costs off)
 select array_agg(c1 order by c1) from ft1 where c1 < 100 group by c2 order by 1;
-                                         QUERY PLAN                                         
---------------------------------------------------------------------------------------------
+                                                    QUERY PLAN                                                     
+-------------------------------------------------------------------------------------------------------------------
  Sort
    Output: (array_agg(c1 ORDER BY c1)), c2
    Sort Key: (array_agg(ft1.c1 ORDER BY ft1.c1))
    ->  GroupAggregate
          Output: array_agg(c1 ORDER BY c1), c2
          Group Key: ft1.c2
-         ->  Sort
-               Output: c2, c1
-               Sort Key: ft1.c2
-               ->  Foreign Scan on public.ft1
-                     Output: c2, c1
-                     SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`C 1` < 100))
-(12 rows)
+         ->  Foreign Scan on public.ft1
+               Output: c1, c2
+               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`C 1` < 100)) ORDER BY `c2` ASC NULLS LAST
+(9 rows)
 
 select array_agg(c1 order by c1) from ft1 where c1 < 100 group by c2 order by 1;
            array_agg            
@@ -3333,8 +3184,8 @@ select array_agg(c5 order by c1 desc) from ft2 where c2 = 6 and c1 < 50;
 -- DISTINCT within aggregate
 explain (verbose, costs off)
 select array_agg(distinct (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
-                                   QUERY PLAN                                    
----------------------------------------------------------------------------------
+                                                  QUERY PLAN                                                  
+--------------------------------------------------------------------------------------------------------------
  Sort
    Output: (array_agg(DISTINCT (t1.c1 % 5))), ((t2.c1 % 3))
    Sort Key: (array_agg(DISTINCT (t1.c1 % 5)))
@@ -3344,25 +3195,19 @@ select array_agg(distinct (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2
          ->  Sort
                Output: ((t2.c1 % 3)), t1.c1
                Sort Key: ((t2.c1 % 3))
-               ->  Merge Full Join
+               ->  Hash Full Join
                      Output: (t2.c1 % 3), t1.c1
-                     Merge Cond: (t1.c1 = t2.c1)
+                     Hash Cond: (t1.c1 = t2.c1)
                      Filter: ((t1.c1 < 20) OR ((t1.c1 IS NULL) AND (t2.c1 < 5)))
-                     ->  Sort
-                           Output: t1.c1
-                           Sort Key: t1.c1
-                           ->  Foreign Scan on public.ft4 t1
-                                 Output: t1.c1
-                                 SQLite query: SELECT `c1` FROM main."T 3"
-                     ->  Materialize
+                     ->  Foreign Scan on public.ft4 t1
+                           Output: t1.c1, t1.c2, t1.c3
+                           SQLite query: SELECT `c1` FROM main."T 3"
+                     ->  Hash
                            Output: t2.c1
-                           ->  Sort
+                           ->  Foreign Scan on public.ft5 t2
                                  Output: t2.c1
-                                 Sort Key: t2.c1
-                                 ->  Foreign Scan on public.ft5 t2
-                                       Output: t2.c1
-                                       SQLite query: SELECT `c1` FROM main."T 4"
-(27 rows)
+                                 SQLite query: SELECT `c1` FROM main."T 4" ORDER BY (`c1` % 3) ASC NULLS LAST
+(21 rows)
 
 select array_agg(distinct (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
   array_agg   
@@ -3374,8 +3219,8 @@ select array_agg(distinct (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2
 -- DISTINCT combined with ORDER BY within aggregate
 explain (verbose, costs off)
 select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
-                                     QUERY PLAN                                      
--------------------------------------------------------------------------------------
+                                                  QUERY PLAN                                                  
+--------------------------------------------------------------------------------------------------------------
  Sort
    Output: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5))), ((t2.c1 % 3))
    Sort Key: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5)))
@@ -3385,25 +3230,19 @@ select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5) from ft4 t1 full join ft
          ->  Sort
                Output: ((t2.c1 % 3)), t1.c1
                Sort Key: ((t2.c1 % 3))
-               ->  Merge Full Join
+               ->  Hash Full Join
                      Output: (t2.c1 % 3), t1.c1
-                     Merge Cond: (t1.c1 = t2.c1)
+                     Hash Cond: (t1.c1 = t2.c1)
                      Filter: ((t1.c1 < 20) OR ((t1.c1 IS NULL) AND (t2.c1 < 5)))
-                     ->  Sort
-                           Output: t1.c1
-                           Sort Key: t1.c1
-                           ->  Foreign Scan on public.ft4 t1
-                                 Output: t1.c1
-                                 SQLite query: SELECT `c1` FROM main."T 3"
-                     ->  Materialize
+                     ->  Foreign Scan on public.ft4 t1
+                           Output: t1.c1, t1.c2, t1.c3
+                           SQLite query: SELECT `c1` FROM main."T 3"
+                     ->  Hash
                            Output: t2.c1
-                           ->  Sort
+                           ->  Foreign Scan on public.ft5 t2
                                  Output: t2.c1
-                                 Sort Key: t2.c1
-                                 ->  Foreign Scan on public.ft5 t2
-                                       Output: t2.c1
-                                       SQLite query: SELECT `c1` FROM main."T 4"
-(27 rows)
+                                 SQLite query: SELECT `c1` FROM main."T 4" ORDER BY (`c1` % 3) ASC NULLS LAST
+(21 rows)
 
 select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
   array_agg   
@@ -3414,8 +3253,8 @@ select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5) from ft4 t1 full join ft
 
 explain (verbose, costs off)
 select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5 desc nulls last) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
-                                             QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
+                                                  QUERY PLAN                                                  
+--------------------------------------------------------------------------------------------------------------
  Sort
    Output: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5) DESC NULLS LAST)), ((t2.c1 % 3))
    Sort Key: (array_agg(DISTINCT (t1.c1 % 5) ORDER BY (t1.c1 % 5) DESC NULLS LAST))
@@ -3425,25 +3264,19 @@ select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5 desc nulls last) from ft4
          ->  Sort
                Output: ((t2.c1 % 3)), t1.c1
                Sort Key: ((t2.c1 % 3))
-               ->  Merge Full Join
+               ->  Hash Full Join
                      Output: (t2.c1 % 3), t1.c1
-                     Merge Cond: (t1.c1 = t2.c1)
+                     Hash Cond: (t1.c1 = t2.c1)
                      Filter: ((t1.c1 < 20) OR ((t1.c1 IS NULL) AND (t2.c1 < 5)))
-                     ->  Sort
-                           Output: t1.c1
-                           Sort Key: t1.c1
-                           ->  Foreign Scan on public.ft4 t1
-                                 Output: t1.c1
-                                 SQLite query: SELECT `c1` FROM main."T 3"
-                     ->  Materialize
+                     ->  Foreign Scan on public.ft4 t1
+                           Output: t1.c1, t1.c2, t1.c3
+                           SQLite query: SELECT `c1` FROM main."T 3"
+                     ->  Hash
                            Output: t2.c1
-                           ->  Sort
+                           ->  Foreign Scan on public.ft5 t2
                                  Output: t2.c1
-                                 Sort Key: t2.c1
-                                 ->  Foreign Scan on public.ft5 t2
-                                       Output: t2.c1
-                                       SQLite query: SELECT `c1` FROM main."T 4"
-(27 rows)
+                                 SQLite query: SELECT `c1` FROM main."T 4" ORDER BY (`c1` % 3) ASC NULLS LAST
+(21 rows)
 
 select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5 desc nulls last) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) where t1.c1 < 20 or (t1.c1 is null and t2.c1 < 5) group by (t2.c1)%3 order by 1;
   array_agg   
@@ -3455,17 +3288,17 @@ select array_agg(distinct (t1.c1)%5 order by (t1.c1)%5 desc nulls last) from ft4
 -- FILTER within aggregate
 explain (verbose, costs off)
 select sum(c1) filter (where c1 < 100 and c2 > 5) from ft1 group by c2 order by 1 nulls last;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
+                                         QUERY PLAN                                          
+---------------------------------------------------------------------------------------------
  Sort
    Output: (sum(c1) FILTER (WHERE ((c1 < 100) AND (c2 > 5)))), c2
    Sort Key: (sum(ft1.c1) FILTER (WHERE ((ft1.c1 < 100) AND (ft1.c2 > 5))))
-   ->  HashAggregate
+   ->  GroupAggregate
          Output: sum(c1) FILTER (WHERE ((c1 < 100) AND (c2 > 5))), c2
          Group Key: ft1.c2
          ->  Foreign Scan on public.ft1
                Output: c1, c2
-               SQLite query: SELECT `C 1`, `c2` FROM main."T 1"
+               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" ORDER BY `c2` ASC NULLS LAST
 (9 rows)
 
 select sum(c1) filter (where c1 < 100 and c2 > 5) from ft1 group by c2 order by 1 nulls last;
@@ -3565,12 +3398,12 @@ select sum(c1) filter (where (c1 / c1) * random() <= 1) from ft1 group by c2 ord
  Sort
    Output: (sum(c1) FILTER (WHERE ((((c1 / c1))::double precision * random()) <= '1'::double precision))), c2
    Sort Key: (sum(ft1.c1) FILTER (WHERE ((((ft1.c1 / ft1.c1))::double precision * random()) <= '1'::double precision)))
-   ->  HashAggregate
+   ->  GroupAggregate
          Output: sum(c1) FILTER (WHERE ((((c1 / c1))::double precision * random()) <= '1'::double precision)), c2
          Group Key: ft1.c2
          ->  Foreign Scan on public.ft1
                Output: c1, c2
-               SQLite query: SELECT `C 1`, `c2` FROM main."T 1"
+               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" ORDER BY `c2` ASC NULLS LAST
 (9 rows)
 
 explain (verbose, costs off)
@@ -3599,13 +3432,10 @@ select c2, rank('10'::varchar) within group (order by c6), percentile_cont(c2/10
    Output: c2, rank('10'::character varying) WITHIN GROUP (ORDER BY c6), percentile_cont((((c2)::numeric / '10'::numeric))::double precision) WITHIN GROUP (ORDER BY ((c1)::double precision))
    Group Key: ft1.c2
    Filter: (percentile_cont((((ft1.c2)::numeric / '10'::numeric))::double precision) WITHIN GROUP (ORDER BY ((ft1.c1)::double precision)) < '500'::double precision)
-   ->  Sort
+   ->  Foreign Scan on public.ft1
          Output: c2, c6, c1
-         Sort Key: ft1.c2
-         ->  Foreign Scan on public.ft1
-               Output: c2, c6, c1
-               SQLite query: SELECT `C 1`, `c2`, `c6` FROM main."T 1" WHERE ((`c2` < 10))
-(10 rows)
+         SQLite query: SELECT `C 1`, `c2`, `c6` FROM main."T 1" WHERE ((`c2` < 10)) ORDER BY `c2` ASC NULLS LAST
+(7 rows)
 
 select c2, rank('10'::varchar) within group (order by c6), percentile_cont(c2/10::numeric) within group (order by c1) from ft1 where c2 < 10 group by c2 having percentile_cont(c2/10::numeric) within group (order by c1) < 500 order by c2;
  c2 | rank | percentile_cont 
@@ -3620,18 +3450,15 @@ select c2, rank('10'::varchar) within group (order by c6), percentile_cont(c2/10
 -- Using multiple arguments within aggregates
 explain (verbose, costs off)
 select c1, rank(c1, c2) within group (order by c1, c2) from ft1 group by c1, c2 having c1 = 6 order by 1;
-                                     QUERY PLAN                                     
-------------------------------------------------------------------------------------
+                                                QUERY PLAN                                                 
+-----------------------------------------------------------------------------------------------------------
  GroupAggregate
    Output: c1, rank(c1, c2) WITHIN GROUP (ORDER BY c1, c2), c2
    Group Key: ft1.c1, ft1.c2
-   ->  Sort
+   ->  Foreign Scan on public.ft1
          Output: c1, c2
-         Sort Key: ft1.c2
-         ->  Foreign Scan on public.ft1
-               Output: c1, c2
-               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`C 1` = 6))
-(9 rows)
+         SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`C 1` = 6)) ORDER BY `c2` ASC NULLS LAST
+(6 rows)
 
 select c1, rank(c1, c2) within group (order by c1, c2) from ft1 group by c1, c2 having c1 = 6 order by 1;
  c1 | rank 
@@ -3708,8 +3535,8 @@ select count(*), x.b from ft1, (select c2 a, sum(c1) b from ft1 group by c2) x w
 -- FULL join with IS NULL check in HAVING
 explain (verbose, costs off)
 select avg(t1.c1), sum(t2.c1) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) group by t2.c1 having (avg(t1.c1) is null and sum(t2.c1) < 10) or sum(t2.c1) is null order by 1 nulls last, 2;
-                                       QUERY PLAN                                       
-----------------------------------------------------------------------------------------
+                                            QUERY PLAN                                            
+--------------------------------------------------------------------------------------------------
  Sort
    Output: (avg(t1.c1)), (sum(t2.c1)), t2.c1
    Sort Key: (avg(t1.c1)), (sum(t2.c1))
@@ -3717,24 +3544,18 @@ select avg(t1.c1), sum(t2.c1) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) gr
          Output: avg(t1.c1), sum(t2.c1), t2.c1
          Group Key: t2.c1
          Filter: (((avg(t1.c1) IS NULL) AND (sum(t2.c1) < 10)) OR (sum(t2.c1) IS NULL))
-         ->  Merge Full Join
+         ->  Hash Full Join
                Output: t2.c1, t1.c1
-               Merge Cond: (t1.c1 = t2.c1)
-               ->  Sort
-                     Output: t1.c1
-                     Sort Key: t1.c1
-                     ->  Foreign Scan on public.ft4 t1
-                           Output: t1.c1
-                           SQLite query: SELECT `c1` FROM main."T 3"
-               ->  Materialize
+               Hash Cond: (t1.c1 = t2.c1)
+               ->  Foreign Scan on public.ft4 t1
+                     Output: t1.c1, t1.c2, t1.c3
+                     SQLite query: SELECT `c1` FROM main."T 3"
+               ->  Hash
                      Output: t2.c1
-                     ->  Sort
+                     ->  Foreign Scan on public.ft5 t2
                            Output: t2.c1
-                           Sort Key: t2.c1
-                           ->  Foreign Scan on public.ft5 t2
-                                 Output: t2.c1
-                                 SQLite query: SELECT `c1` FROM main."T 4"
-(24 rows)
+                           SQLite query: SELECT `c1` FROM main."T 4" ORDER BY `c1` ASC NULLS LAST
+(18 rows)
 
 select avg(t1.c1), sum(t2.c1) from ft4 t1 full join ft5 t2 on (t1.c1 = t2.c1) group by t2.c1 having (avg(t1.c1) is null and sum(t2.c1) < 10) or sum(t2.c1) is null order by 1 nulls last, 2;
          avg         | sum 
@@ -3801,23 +3622,20 @@ select sum(c2) * (random() <= 1)::int as sum from ft1 order by 1;
 set enable_hashagg to false;
 explain (verbose, costs off)
 select c2, sum from "S 1"."T 1" t1, lateral (select sum(t2.c1 + t1."C 1") sum from ft2 t2 group by t2.c1) qry where t1.c2 * 2 = qry.sum and t1.c2 < 3 and t1."C 1" < 100 order by 1;
-                                              QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
- Sort
+                                                          QUERY PLAN                                                          
+------------------------------------------------------------------------------------------------------------------------------
+ Nested Loop
    Output: t1.c2, qry.sum
-   Sort Key: t1.c2
-   ->  Nested Loop
-         Output: t1.c2, qry.sum
-         ->  Foreign Scan on "S 1"."T 1" t1
-               Output: t1."C 1", t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
-               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`c2` < 3)) AND ((`C 1` < 100))
-         ->  Subquery Scan on qry
-               Output: qry.sum, t2.c1
-               Filter: (((t1.c2 * 2))::numeric = qry.sum)
-               ->  Foreign Scan
-                     Output: (sum((t2.c1 + t1."C 1"))), t2.c1
-                     SQLite query: SELECT sum((`C 1` + ?)), `C 1` FROM main."T 1" GROUP BY 2
-(14 rows)
+   ->  Foreign Scan on "S 1"."T 1" t1
+         Output: t1."C 1", t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
+         SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`c2` < 3)) AND ((`C 1` < 100)) ORDER BY `c2` ASC NULLS LAST
+   ->  Subquery Scan on qry
+         Output: qry.sum, t2.c1
+         Filter: (((t1.c2 * 2))::numeric = qry.sum)
+         ->  Foreign Scan
+               Output: (sum((t2.c1 + t1."C 1"))), t2.c1
+               SQLite query: SELECT sum((`C 1` + ?)), `C 1` FROM main."T 1" GROUP BY 2
+(11 rows)
 
 select c2, sum from "S 1"."T 1" t1, lateral (select sum(t2.c1 + t1."C 1") sum from ft2 t2 group by t2.c1) qry where t1.c2 * 2 = qry.sum and t1.c2 < 3 and t1."C 1" < 100 order by 1;
  c2 | sum 
@@ -3876,19 +3694,16 @@ select sum(q.a), count(q.b) from ft4 left join (select 13, avg(ft1.c1), sum(ft2.
 -- Grouping sets
 explain (verbose, costs off)
 select c2, sum(c1) from ft1 where c2 < 3 group by rollup(c2) order by 1 nulls last;
-                                    QUERY PLAN                                     
------------------------------------------------------------------------------------
- Sort
-   Output: c2, (sum(c1))
-   Sort Key: ft1.c2
-   ->  MixedAggregate
-         Output: c2, sum(c1)
-         Hash Key: ft1.c2
-         Group Key: ()
-         ->  Foreign Scan on public.ft1
-               Output: c2, c1
-               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`c2` < 3))
-(10 rows)
+                                                QUERY PLAN                                                
+----------------------------------------------------------------------------------------------------------
+ GroupAggregate
+   Output: c2, sum(c1)
+   Group Key: ft1.c2
+   Group Key: ()
+   ->  Foreign Scan on public.ft1
+         Output: c2, c1
+         SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`c2` < 3)) ORDER BY `c2` ASC NULLS LAST
+(7 rows)
 
 select c2, sum(c1) from ft1 where c2 < 3 group by rollup(c2) order by 1 nulls last;
  c2 |  sum   
@@ -3901,19 +3716,16 @@ select c2, sum(c1) from ft1 where c2 < 3 group by rollup(c2) order by 1 nulls la
 
 explain (verbose, costs off)
 select c2, sum(c1) from ft1 where c2 < 3 group by cube(c2) order by 1 nulls last;
-                                    QUERY PLAN                                     
------------------------------------------------------------------------------------
- Sort
-   Output: c2, (sum(c1))
-   Sort Key: ft1.c2
-   ->  MixedAggregate
-         Output: c2, sum(c1)
-         Hash Key: ft1.c2
-         Group Key: ()
-         ->  Foreign Scan on public.ft1
-               Output: c2, c1
-               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`c2` < 3))
-(10 rows)
+                                                QUERY PLAN                                                
+----------------------------------------------------------------------------------------------------------
+ GroupAggregate
+   Output: c2, sum(c1)
+   Group Key: ft1.c2
+   Group Key: ()
+   ->  Foreign Scan on public.ft1
+         Output: c2, c1
+         SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`c2` < 3)) ORDER BY `c2` ASC NULLS LAST
+(7 rows)
 
 select c2, sum(c1) from ft1 where c2 < 3 group by cube(c2) order by 1 nulls last;
  c2 |  sum   
@@ -3926,18 +3738,18 @@ select c2, sum(c1) from ft1 where c2 < 3 group by cube(c2) order by 1 nulls last
 
 explain (verbose, costs off)
 select c2, c6, sum(c1) from ft1 where c2 < 3 group by grouping sets(c2, c6) order by 1 nulls last, 2 nulls last;
-                                       QUERY PLAN                                        
------------------------------------------------------------------------------------------
+                                                      QUERY PLAN                                                      
+----------------------------------------------------------------------------------------------------------------------
  Sort
    Output: c2, c6, (sum(c1))
    Sort Key: ft1.c2, ft1.c6
-   ->  HashAggregate
+   ->  MixedAggregate
          Output: c2, c6, sum(c1)
-         Hash Key: ft1.c2
          Hash Key: ft1.c6
+         Group Key: ft1.c2
          ->  Foreign Scan on public.ft1
                Output: c2, c6, c1
-               SQLite query: SELECT `C 1`, `c2`, `c6` FROM main."T 1" WHERE ((`c2` < 3))
+               SQLite query: SELECT `C 1`, `c2`, `c6` FROM main."T 1" WHERE ((`c2` < 3)) ORDER BY `c2` ASC NULLS LAST
 (10 rows)
 
 select c2, c6, sum(c1) from ft1 where c2 < 3 group by grouping sets(c2, c6) order by 1 nulls last, 2 nulls last;
@@ -3953,18 +3765,15 @@ select c2, c6, sum(c1) from ft1 where c2 < 3 group by grouping sets(c2, c6) orde
 
 explain (verbose, costs off)
 select c2, sum(c1), grouping(c2) from ft1 where c2 < 3 group by c2 order by 1 nulls last;
-                                    QUERY PLAN                                     
------------------------------------------------------------------------------------
- Sort
-   Output: c2, (sum(c1)), (GROUPING(c2))
-   Sort Key: ft1.c2
-   ->  HashAggregate
-         Output: c2, sum(c1), GROUPING(c2)
-         Group Key: ft1.c2
-         ->  Foreign Scan on public.ft1
-               Output: c2, c1
-               SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`c2` < 3))
-(9 rows)
+                                                QUERY PLAN                                                
+----------------------------------------------------------------------------------------------------------
+ GroupAggregate
+   Output: c2, sum(c1), GROUPING(c2)
+   Group Key: ft1.c2
+   ->  Foreign Scan on public.ft1
+         Output: c2, c1
+         SQLite query: SELECT `C 1`, `c2` FROM main."T 1" WHERE ((`c2` < 3)) ORDER BY `c2` ASC NULLS LAST
+(6 rows)
 
 select c2, sum(c1), grouping(c2) from ft1 where c2 < 3 group by c2 order by 1 nulls last;
  c2 |  sum  | grouping 
@@ -4128,28 +3937,21 @@ EXECUTE st1(101, 101);
 -- subquery using stable function (can't be sent to remote)
 PREPARE st2(int) AS SELECT * FROM ft1 t1 WHERE t1.c1 < $2 AND t1.c3 IN (SELECT c3 FROM ft2 t2 WHERE c1 > $1 AND date(c4) = '1970-01-17'::date) ORDER BY c1;
 EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st2(10, 20);
-                                                       QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
- Sort
+                                                                   QUERY PLAN                                                                    
+-------------------------------------------------------------------------------------------------------------------------------------------------
+ Nested Loop Semi Join
    Output: t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
-   Sort Key: t1.c1
-   ->  Hash Join
+   Join Filter: (t1.c3 = t2.c3)
+   ->  Foreign Scan on public.ft1 t1
          Output: t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
-         Inner Unique: true
-         Hash Cond: (t1.c3 = t2.c3)
-         ->  Foreign Scan on public.ft1 t1
-               Output: t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
-               SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" WHERE ((`C 1` < 20))
-         ->  Hash
+         SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" WHERE ((`C 1` < 20)) ORDER BY `C 1` ASC NULLS LAST
+   ->  Materialize
+         Output: t2.c3
+         ->  Foreign Scan on public.ft2 t2
                Output: t2.c3
-               ->  HashAggregate
-                     Output: t2.c3
-                     Group Key: t2.c3
-                     ->  Foreign Scan on public.ft2 t2
-                           Output: t2.c3
-                           Filter: (date(t2.c4) = '01-17-1970'::date)
-                           SQLite query: SELECT `c3`, `c4` FROM main."T 1" WHERE ((`C 1` > 10))
-(19 rows)
+               Filter: (date(t2.c4) = '01-17-1970'::date)
+               SQLite query: SELECT `c3`, `c4` FROM main."T 1" WHERE ((`C 1` > 10))
+(12 rows)
 
 EXECUTE st2(10, 20);
  c1 | c2 |  c3   |              c4              |            c5            | c6 |     c7     | c8  
@@ -4166,28 +3968,21 @@ EXECUTE st2(101, 121);
 -- subquery using immutable function (can be sent to remote)
 PREPARE st3(int) AS SELECT * FROM ft1 t1 WHERE t1.c1 < $2 AND t1.c3 IN (SELECT c3 FROM ft2 t2 WHERE c1 > $1 AND date(c5) = '1970-01-17'::date) ORDER BY c1;
 EXPLAIN (VERBOSE, COSTS OFF) EXECUTE st3(10, 20);
-                                                       QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
- Sort
+                                                                   QUERY PLAN                                                                    
+-------------------------------------------------------------------------------------------------------------------------------------------------
+ Nested Loop Semi Join
    Output: t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
-   Sort Key: t1.c1
-   ->  Hash Join
+   Join Filter: (t1.c3 = t2.c3)
+   ->  Foreign Scan on public.ft1 t1
          Output: t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
-         Inner Unique: true
-         Hash Cond: (t1.c3 = t2.c3)
-         ->  Foreign Scan on public.ft1 t1
-               Output: t1.c1, t1.c2, t1.c3, t1.c4, t1.c5, t1.c6, t1.c7, t1.c8
-               SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" WHERE ((`C 1` < 20))
-         ->  Hash
+         SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" WHERE ((`C 1` < 20)) ORDER BY `C 1` ASC NULLS LAST
+   ->  Materialize
+         Output: t2.c3
+         ->  Foreign Scan on public.ft2 t2
                Output: t2.c3
-               ->  HashAggregate
-                     Output: t2.c3
-                     Group Key: t2.c3
-                     ->  Foreign Scan on public.ft2 t2
-                           Output: t2.c3
-                           Filter: (date(t2.c5) = '01-17-1970'::date)
-                           SQLite query: SELECT `c3`, `c5` FROM main."T 1" WHERE ((`C 1` > 10))
-(19 rows)
+               Filter: (date(t2.c5) = '01-17-1970'::date)
+               SQLite query: SELECT `c3`, `c5` FROM main."T 1" WHERE ((`C 1` > 10))
+(12 rows)
 
 EXECUTE st3(10, 20);
  c1 | c2 |  c3   |              c4              |            c5            | c6 |     c7     | c8  
@@ -4378,14 +4173,12 @@ SELECT * FROM ft1 t1 WHERE t1.tableoid = 'ft1'::regclass LIMIT 1;
 
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT tableoid::regclass, * FROM ft1 t1 LIMIT 1;
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
- Limit
-   Output: ((tableoid)::regclass), c1, c2, c3, c4, c5, c6, c7, c8
-   ->  Foreign Scan on public.ft1 t1
-         Output: (tableoid)::regclass, c1, c2, c3, c4, c5, c6, c7, c8
-         SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(5 rows)
+                                           QUERY PLAN                                           
+------------------------------------------------------------------------------------------------
+ Foreign Scan on public.ft1 t1
+   Output: (tableoid)::regclass, c1, c2, c3, c4, c5, c6, c7, c8
+   SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" LIMIT 1
+(3 rows)
 
 SELECT tableoid::regclass, * FROM ft1 t1 LIMIT 1;
  tableoid | c1 | c2 |  c3   |              c4              |            c5            | c6 |     c7     | c8  
@@ -4413,14 +4206,12 @@ SELECT * FROM ft1 t1 WHERE t1.ctid = '(4294967295,0)' LIMIT 1;
 
 EXPLAIN (VERBOSE, COSTS OFF)
 SELECT ctid, * FROM ft1 t1 LIMIT 1;
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
- Limit
+                                           QUERY PLAN                                           
+------------------------------------------------------------------------------------------------
+ Foreign Scan on public.ft1 t1
    Output: ctid, c1, c2, c3, c4, c5, c6, c7, c8
-   ->  Foreign Scan on public.ft1 t1
-         Output: ctid, c1, c2, c3, c4, c5, c6, c7, c8
-         SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(5 rows)
+   SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" LIMIT 1
+(3 rows)
 
 SELECT ctid, * FROM ft1 t1 LIMIT 1;
       ctid      | c1 | c2 |  c3   |              c4              |            c5            | c6 |     c7     | c8  
@@ -4530,12 +4321,10 @@ INSERT INTO ft2 (c1,c2,c3) SELECT c1+1000,c2+100, c3 || c3 FROM ft2 LIMIT 20;
  Insert on public.ft2
    ->  Subquery Scan on "*SELECT*"
          Output: "*SELECT*"."?column?", "*SELECT*"."?column?_1", NULL::integer, "*SELECT*"."?column?_2", NULL::timestamp with time zone, NULL::timestamp without time zone, NULL::character varying, 'ft2       '::character(10), NULL::text
-         ->  Limit
-               Output: ((ft2_1.c1 + 1000)), ((ft2_1.c2 + 100)), ((ft2_1.c3 || ft2_1.c3))
-               ->  Foreign Scan on public.ft2 ft2_1
-                     Output: (ft2_1.c1 + 1000), (ft2_1.c2 + 100), (ft2_1.c3 || ft2_1.c3)
-                     SQLite query: SELECT `C 1`, `c2`, `c3` FROM main."T 1"
-(8 rows)
+         ->  Foreign Scan on public.ft2 ft2_1
+               Output: (ft2_1.c1 + 1000), (ft2_1.c2 + 100), (ft2_1.c3 || ft2_1.c3)
+               SQLite query: SELECT `C 1`, `c2`, `c3` FROM main."T 1" LIMIT 20
+(6 rows)
 
 INSERT INTO ft2 (c1,c2,c3) SELECT c1+1000,c2+100, c3 || c3 FROM ft2 LIMIT 20;
 INSERT INTO ft2 (c1,c2,c3) VALUES (1101,201,'aaa'), (1102,202,'bbb'), (1103,203,'ccc');
@@ -5841,7 +5630,7 @@ SELECT * FROM ft2 WHERE c1 % 10 = 8 AND c1 < 1200;
 
 -- Test errors thrown on remote side during update
 INSERT INTO ft1(c1, c2) VALUES(11, 12);  -- duplicate key
-ERROR:  failed to execute remote SQL: rc=19 column C 1 is not unique 
+ERROR:  failed to execute remote SQL: rc=19 UNIQUE constraint failed: T 1.C 1 
    sql=INSERT INTO main."T 1"(`C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8`) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
 INSERT INTO ft1(c1, c2) VALUES(11, 12) ON CONFLICT (c1, c2) DO NOTHING; -- unsupported
 ERROR:  there is no unique or exclusion constraint matching the ON CONFLICT specification
@@ -6101,17 +5890,12 @@ select c2, count(*) from "S 1"."T 1" where c2 < 500 group by 1 order by 1;
 -- FIRST behavior here.
 -- ORDER BY DESC NULLS LAST options
 EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 ORDER BY c6 DESC NULLS LAST, c1 OFFSET 795 LIMIT 10;
-                                             QUERY PLAN                                             
-----------------------------------------------------------------------------------------------------
- Limit
+                                                                           QUERY PLAN                                                                           
+----------------------------------------------------------------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.ft1
    Output: c1, c2, c3, c4, c5, c6, c7, c8
-   ->  Sort
-         Output: c1, c2, c3, c4, c5, c6, c7, c8
-         Sort Key: ft1.c6 DESC NULLS LAST, ft1.c1
-         ->  Foreign Scan on public.ft1
-               Output: c1, c2, c3, c4, c5, c6, c7, c8
-               SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(8 rows)
+   SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" ORDER BY `c6` DESC NULLS LAST, `C 1` ASC NULLS LAST LIMIT 10 OFFSET 795
+(3 rows)
 
 SELECT * FROM ft1 ORDER BY c6 DESC NULLS LAST, c1 OFFSET 795  LIMIT 10;
   c1  | c2  |         c3         |              c4              |            c5            |  c6  |     c7     | c8  
@@ -6130,17 +5914,12 @@ SELECT * FROM ft1 ORDER BY c6 DESC NULLS LAST, c1 OFFSET 795  LIMIT 10;
 
 -- ORDER BY DESC NULLS FIRST options
 EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 ORDER BY c6 DESC NULLS FIRST, c1 OFFSET 15 LIMIT 10;
-                                             QUERY PLAN                                             
-----------------------------------------------------------------------------------------------------
- Limit
+                                                                           QUERY PLAN                                                                           
+----------------------------------------------------------------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.ft1
    Output: c1, c2, c3, c4, c5, c6, c7, c8
-   ->  Sort
-         Output: c1, c2, c3, c4, c5, c6, c7, c8
-         Sort Key: ft1.c6 DESC, ft1.c1
-         ->  Foreign Scan on public.ft1
-               Output: c1, c2, c3, c4, c5, c6, c7, c8
-               SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(8 rows)
+   SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" ORDER BY `c6` DESC NULLS FIRST, `C 1` ASC NULLS LAST LIMIT 10 OFFSET 15
+(3 rows)
 
 SELECT * FROM ft1 ORDER BY c6 DESC NULLS FIRST, c1 OFFSET 15 LIMIT 10;
   c1  | c2  |       c3        |              c4              |            c5            | c6 |     c7     | c8  
@@ -6159,17 +5938,12 @@ SELECT * FROM ft1 ORDER BY c6 DESC NULLS FIRST, c1 OFFSET 15 LIMIT 10;
 
 -- ORDER BY ASC NULLS FIRST options
 EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM ft1 ORDER BY c6 ASC NULLS FIRST, c1 OFFSET 15 LIMIT 10;
-                                             QUERY PLAN                                             
-----------------------------------------------------------------------------------------------------
- Limit
+                                                                          QUERY PLAN                                                                           
+---------------------------------------------------------------------------------------------------------------------------------------------------------------
+ Foreign Scan on public.ft1
    Output: c1, c2, c3, c4, c5, c6, c7, c8
-   ->  Sort
-         Output: c1, c2, c3, c4, c5, c6, c7, c8
-         Sort Key: ft1.c6 NULLS FIRST, ft1.c1
-         ->  Foreign Scan on public.ft1
-               Output: c1, c2, c3, c4, c5, c6, c7, c8
-               SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1"
-(8 rows)
+   SQLite query: SELECT `C 1`, `c2`, `c3`, `c4`, `c5`, `c6`, `c7`, `c8` FROM main."T 1" ORDER BY `c6` ASC NULLS FIRST, `C 1` ASC NULLS LAST LIMIT 10 OFFSET 15
+(3 rows)
 
 SELECT * FROM ft1 ORDER BY c6 ASC NULLS FIRST, c1 OFFSET 15 LIMIT 10;
   c1  | c2  |        c3         |              c4              |            c5            |  c6  |     c7     | c8  
@@ -6895,9 +6669,9 @@ select * from bar where f1 in (select f1 from foo) for update;
                                           QUERY PLAN                                          
 ----------------------------------------------------------------------------------------------
  LockRows
-   Output: bar.f1, bar.f2, bar.ctid, bar.*, bar.tableoid, foo.ctid, foo.*, foo.tableoid
+   Output: bar.f1, bar.f2, bar.ctid, foo.ctid, bar.*, bar.tableoid, foo.*, foo.tableoid
    ->  Hash Join
-         Output: bar.f1, bar.f2, bar.ctid, bar.*, bar.tableoid, foo.ctid, foo.*, foo.tableoid
+         Output: bar.f1, bar.f2, bar.ctid, foo.ctid, bar.*, bar.tableoid, foo.*, foo.tableoid
          Inner Unique: true
          Hash Cond: (bar.f1 = foo.f1)
          ->  Append
@@ -6907,15 +6681,15 @@ select * from bar where f1 in (select f1 from foo) for update;
                      Output: bar2.f1, bar2.f2, bar2.ctid, bar2.*, bar2.tableoid
                      SQLite query: SELECT `f1`, `f2`, `f3` FROM main."loct2"
          ->  Hash
-               Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+               Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                ->  HashAggregate
-                     Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+                     Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                      Group Key: foo.f1
                      ->  Append
                            ->  Seq Scan on public.foo
-                                 Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+                                 Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                            ->  Foreign Scan on public.foo2
-                                 Output: foo2.ctid, foo2.*, foo2.tableoid, foo2.f1
+                                 Output: foo2.ctid, foo2.f1, foo2.*, foo2.tableoid
                                  SQLite query: SELECT `f1`, `f2`, `f3` FROM main."loct1"
 (23 rows)
 
@@ -6933,9 +6707,9 @@ select * from bar where f1 in (select f1 from foo) for share;
                                           QUERY PLAN                                          
 ----------------------------------------------------------------------------------------------
  LockRows
-   Output: bar.f1, bar.f2, bar.ctid, bar.*, bar.tableoid, foo.ctid, foo.*, foo.tableoid
+   Output: bar.f1, bar.f2, bar.ctid, foo.ctid, bar.*, bar.tableoid, foo.*, foo.tableoid
    ->  Hash Join
-         Output: bar.f1, bar.f2, bar.ctid, bar.*, bar.tableoid, foo.ctid, foo.*, foo.tableoid
+         Output: bar.f1, bar.f2, bar.ctid, foo.ctid, bar.*, bar.tableoid, foo.*, foo.tableoid
          Inner Unique: true
          Hash Cond: (bar.f1 = foo.f1)
          ->  Append
@@ -6945,15 +6719,15 @@ select * from bar where f1 in (select f1 from foo) for share;
                      Output: bar2.f1, bar2.f2, bar2.ctid, bar2.*, bar2.tableoid
                      SQLite query: SELECT `f1`, `f2`, `f3` FROM main."loct2"
          ->  Hash
-               Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+               Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                ->  HashAggregate
-                     Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+                     Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                      Group Key: foo.f1
                      ->  Append
                            ->  Seq Scan on public.foo
-                                 Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+                                 Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                            ->  Foreign Scan on public.foo2
-                                 Output: foo2.ctid, foo2.*, foo2.tableoid, foo2.f1
+                                 Output: foo2.ctid, foo2.f1, foo2.*, foo2.tableoid
                                  SQLite query: SELECT `f1`, `f2`, `f3` FROM main."loct1"
 (23 rows)
 
@@ -6981,15 +6755,15 @@ update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
          ->  Seq Scan on public.bar
                Output: bar.f1, bar.f2, bar.ctid
          ->  Hash
-               Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+               Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                ->  HashAggregate
-                     Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+                     Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                      Group Key: foo.f1
                      ->  Append
                            ->  Seq Scan on public.foo
-                                 Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+                                 Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                            ->  Foreign Scan on public.foo2
-                                 Output: foo2.ctid, foo2.*, foo2.tableoid, foo2.f1
+                                 Output: foo2.ctid, foo2.f1, foo2.*, foo2.tableoid
                                  SQLite query: SELECT `f1`, `f2`, `f3` FROM main."loct1"
    ->  Hash Join
          Output: bar2.f1, (bar2.f2 + 100), bar2.f3, bar2.f3, foo.ctid, foo.*, foo.tableoid
@@ -6999,15 +6773,15 @@ update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
                Output: bar2.f1, bar2.f2, bar2.f3
                SQLite query: SELECT `f1`, `f2`, `f3` FROM main."loct2"
          ->  Hash
-               Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+               Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                ->  HashAggregate
-                     Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+                     Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                      Group Key: foo.f1
                      ->  Append
                            ->  Seq Scan on public.foo
-                                 Output: foo.ctid, foo.*, foo.tableoid, foo.f1
+                                 Output: foo.ctid, foo.f1, foo.*, foo.tableoid
                            ->  Foreign Scan on public.foo2
-                                 Output: foo2.ctid, foo2.*, foo2.tableoid, foo2.f1
+                                 Output: foo2.ctid, foo2.f1, foo2.*, foo2.tableoid
                                  SQLite query: SELECT `f1`, `f2`, `f3` FROM main."loct1"
 (38 rows)
 
diff --git a/expected/extra/timestamp.out b/expected/extra/timestamp.out
new file mode 100644
index 0000000..48e61f5
--- /dev/null
+++ b/expected/extra/timestamp.out
@@ -0,0 +1,104 @@
+--
+-- TIMESTAMP
+--
+CREATE EXTENSION sqlite_fdw;
+CREATE SERVER sqlite_svr FOREIGN DATA WRAPPER sqlite_fdw
+OPTIONS (database '/tmp/sqlitefdw_test_core.db');
+CREATE FOREIGN TABLE dates1 (
+	name varchar(20),
+	date_as_text timestamp without time zone,
+	date_as_number timestamp without time zone)
+SERVER sqlite_svr
+OPTIONS (table 'dates');
+CREATE FOREIGN TABLE dates2 (
+	name varchar(20),
+	date_as_text timestamp without time zone,
+	date_as_number double precision)
+SERVER sqlite_svr
+OPTIONS (table 'dates');
+-- Showing timestamp column from SQLite value as TEXT and as INTEGER/FLOAT has same value
+SELECT name,
+	to_char(date_as_text, 	'YYYY-MM-DD HH24:MI:SS.MS') as date_as_text, 
+	to_char(date_as_number, 'YYYY-MM-DD HH24:MI:SS.MS') as date_as_number
+FROM dates1;
+    name    |      date_as_text       |     date_as_number      
+------------+-------------------------+-------------------------
+ FirstDate  | 2020-05-12 11:45:31.414 | 2020-05-12 11:45:31.414
+ SecondDate | 2020-05-12 13:32:31.500 | 2020-05-12 13:32:31.500
+ ThirdDate  | 2020-05-10 10:45:29.000 | 2020-05-10 10:45:29.000
+(3 rows)
+
+SELECT * FROM dates2;
+    name    |          date_as_text           |  date_as_number  
+------------+---------------------------------+------------------
+ FirstDate  | Tue May 12 11:45:31.414014 2020 | 1589283931.41401
+ SecondDate | Tue May 12 13:32:31.500274 2020 | 1589290351.50027
+ ThirdDate  | Sun May 10 10:45:29 2020        |       1589107529
+(3 rows)
+
+-- Comparing exact values showing same results even comparing to a text source sqlite column or numerical source sqlite column
+SELECT * FROM dates1
+WHERE date_as_text = to_timestamp('2020-05-10 10:45:29.000', 'YYYY-MM-DD HH24:MI:SS.MS');
+   name    |       date_as_text       |      date_as_number      
+-----------+--------------------------+--------------------------
+ ThirdDate | Sun May 10 10:45:29 2020 | Sun May 10 10:45:29 2020
+(1 row)
+
+SELECT * FROM dates1
+WHERE date_as_number = to_timestamp('2020-05-10 10:45:29.000', 'YYYY-MM-DD HH24:MI:SS.MS');
+   name    |       date_as_text       |      date_as_number      
+-----------+--------------------------+--------------------------
+ ThirdDate | Sun May 10 10:45:29 2020 | Sun May 10 10:45:29 2020
+(1 row)
+
+SELECT * FROM dates1
+WHERE date_as_text = to_timestamp('2020-05-10 10:45:29', 'YYYY-MM-DD HH24:MI:SS.MS');
+   name    |       date_as_text       |      date_as_number      
+-----------+--------------------------+--------------------------
+ ThirdDate | Sun May 10 10:45:29 2020 | Sun May 10 10:45:29 2020
+(1 row)
+
+SELECT * FROM dates1
+WHERE date_as_number = to_timestamp('2020-05-10 10:45:29', 'YYYY-MM-DD HH24:MI:SS.MS');
+   name    |       date_as_text       |      date_as_number      
+-----------+--------------------------+--------------------------
+ ThirdDate | Sun May 10 10:45:29 2020 | Sun May 10 10:45:29 2020
+(1 row)
+
+-- Comparing greater values showing same results even comparing to a text source sqlite column or numerical source sqlite column
+SELECT * FROM dates1
+WHERE date_as_text > to_timestamp('2020-05-10 10:45:29.000', 'YYYY-MM-DD HH24:MI:SS.MS');
+    name    |          date_as_text           |         date_as_number         
+------------+---------------------------------+--------------------------------
+ FirstDate  | Tue May 12 11:45:31.414014 2020 | Tue May 12 11:45:31.41401 2020
+ SecondDate | Tue May 12 13:32:31.500274 2020 | Tue May 12 13:32:31.50027 2020
+(2 rows)
+
+SELECT * FROM dates1
+WHERE date_as_number > to_timestamp('2020-05-10 10:45:29.000', 'YYYY-MM-DD HH24:MI:SS.MS');
+    name    |          date_as_text           |         date_as_number         
+------------+---------------------------------+--------------------------------
+ FirstDate  | Tue May 12 11:45:31.414014 2020 | Tue May 12 11:45:31.41401 2020
+ SecondDate | Tue May 12 13:32:31.500274 2020 | Tue May 12 13:32:31.50027 2020
+(2 rows)
+
+SELECT * FROM dates1
+WHERE date_as_text > to_timestamp('2020-05-10 10:45:29', 'YYYY-MM-DD HH24:MI:SS.MS');
+    name    |          date_as_text           |         date_as_number         
+------------+---------------------------------+--------------------------------
+ FirstDate  | Tue May 12 11:45:31.414014 2020 | Tue May 12 11:45:31.41401 2020
+ SecondDate | Tue May 12 13:32:31.500274 2020 | Tue May 12 13:32:31.50027 2020
+(2 rows)
+
+SELECT * FROM dates1
+WHERE date_as_number > to_timestamp('2020-05-10 10:45:29', 'YYYY-MM-DD HH24:MI:SS.MS');
+    name    |          date_as_text           |         date_as_number         
+------------+---------------------------------+--------------------------------
+ FirstDate  | Tue May 12 11:45:31.414014 2020 | Tue May 12 11:45:31.41401 2020
+ SecondDate | Tue May 12 13:32:31.500274 2020 | Tue May 12 13:32:31.50027 2020
+(2 rows)
+
+DROP FOREIGN TABLE dates1;
+DROP FOREIGN TABLE dates2;
+DROP SERVER sqlite_svr;
+DROP EXTENSION sqlite_fdw CASCADE;
diff --git a/expected/sqlite_fdw.out b/expected/sqlite_fdw.out
index 2dad994..3597d6a 100644
--- a/expected/sqlite_fdw.out
+++ b/expected/sqlite_fdw.out
@@ -94,7 +94,7 @@ SELECT * FROM department d, employee e WHERE d.department_id = e.emp_dept_id LIM
             10 | dept - 10       |     10 | emp - 10 |          10
 (10 rows)
 
-SELECT * FROM department d, employee e WHERE d.department_id IN (SELECT department_id FROM department) LIMIT 10;
+SELECT * FROM department d, employee e WHERE d.department_id IN (SELECT department_id FROM department) ORDER BY d.department_id LIMIT 10;
  department_id | department_name | emp_id | emp_name | emp_dept_id 
 ---------------+-----------------+--------+----------+-------------
              1 | dept - 1        |      1 | emp - 1  |           1
diff --git a/run_base_tests.sh b/run_base_tests.sh
new file mode 100644
index 0000000..a02cb7b
--- /dev/null
+++ b/run_base_tests.sh
@@ -0,0 +1,7 @@
+rm /tmp/sqlitefdw_test.db
+sqlite3 /tmp/sqlitefdw_test.db < sql/init.sql
+export USE_PGXS=1
+
+sed -i 's/REGRESS =.*/REGRESS = aggregate sqlite_fdw type /' Makefile.extra
+
+make -f Makefile.extra clean && make -f Makefile.extra && make -f Makefile.extra installcheck
\ No newline at end of file
diff --git a/run_extra_tests.sh b/run_extra_tests.sh
new file mode 100644
index 0000000..7886984
--- /dev/null
+++ b/run_extra_tests.sh
@@ -0,0 +1,15 @@
+rm -rf /tmp/sqlitefdw_test*.db
+rm -rf /tmp/*.data
+cp -a sql/extra/*.data /tmp/
+
+sqlite3 /tmp/sqlitefdw_test_post.db < sql/extra/init_post.sql
+sqlite3 /tmp/sqlitefdw_test_core.db < sql/extra/init_core.sql
+
+export USE_PGXS=1
+
+sed -i 's/REGRESS =.*/REGRESS = extra\/sqlite_fdw_post extra\/float4 extra\/float8 extra\/int4 extra\/int8 extra\/numeric extra\/join extra\/limit extra\/aggregates extra\/prepare extra\/select_having extra\/select extra\/insert extra\/update extra\/timestamp /' Makefile.extra
+
+make -f Makefile.extra clean
+make -f Makefile.extra
+mkdir -p results/extra || true
+make -f Makefile.extra installcheck | tee make_check.out
diff --git a/sql/aggregate.sql b/sql/aggregate.sql
index a027d37..6eb2e6e 100644
--- a/sql/aggregate.sql
+++ b/sql/aggregate.sql
@@ -1,3 +1,9 @@
+--SET log_min_messages  TO DEBUG1;
+--SET client_min_messages  TO DEBUG1;
+CREATE EXTENSION sqlite_fdw;
+CREATE SERVER sqlite_svr FOREIGN DATA WRAPPER sqlite_fdw
+OPTIONS (database '/tmp/sqlitefdw_test.db');
+CREATE FOREIGN TABLE multiprimary(a int, b int OPTIONS (key 'true'), c int OPTIONS(key 'true')) SERVER sqlite_svr;
 -- test for aggregate pushdown
 explain (costs off, verbose) select count(distinct a) from multiprimary;
 
@@ -11,4 +17,8 @@ explain (costs off, verbose) select sum(a) from multiprimary group by b having a
 
 -- stddev and variance are not pushed down
 explain (costs off, verbose) select stddev(a) from multiprimary;
-explain (costs off, verbose) select sum(a) from multiprimary group by b having variance(a) > 0;
\ No newline at end of file
+explain (costs off, verbose) select sum(a) from multiprimary group by b having variance(a) > 0;
+
+DROP FOREIGN TABLE multiprimary;
+DROP SERVER sqlite_svr;
+DROP EXTENSION sqlite_fdw CASCADE;
diff --git a/sql/extra/aggregates.sql b/sql/extra/aggregates.sql
index db68f36..c923565 100644
--- a/sql/extra/aggregates.sql
+++ b/sql/extra/aggregates.sql
@@ -72,27 +72,33 @@ SELECT avg(four) AS avg_1 FROM onek;
 SELECT avg(a) AS avg_32 FROM aggtest WHERE a < 100;
 
 -- In 7.1, avg(float4) is computed using float8 arithmetic.
--- Round the result to 3 digits to avoid platform-specific results.
-
+-- Round the result to limited digits to avoid platform-specific results.
 SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
 
-SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT avg(gpa)::numeric(10,3) AS avg_3_4 FROM ONLY student;
 
 
 SELECT sum(four) AS sum_1500 FROM onek;
 SELECT sum(a) AS sum_198 FROM aggtest;
-SELECT sum(b) AS avg_431_773 FROM aggtest;
-SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT sum(b)::numeric(10,3) AS avg_431_773 FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT sum(gpa)::numeric(10,3) AS avg_6_8 FROM ONLY student;
 
 SELECT max(four) AS max_3 FROM onek;
 SELECT max(a) AS max_100 FROM aggtest;
 SELECT max(aggtest.b) AS max_324_78 FROM aggtest;
 SELECT max(student.gpa) AS max_3_7 FROM student;
 
-SELECT stddev_pop(b) FROM aggtest;
-SELECT stddev_samp(b) FROM aggtest;
-SELECT var_pop(b) FROM aggtest;
-SELECT var_samp(b) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT stddev_pop(b)::numeric(20,10) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT stddev_samp(b)::numeric(20,10) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT var_pop(b)::numeric(20,10) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT var_samp(b)::numeric(20,10) FROM aggtest;
 
 SELECT stddev_pop(b::numeric) FROM aggtest;
 SELECT stddev_samp(b::numeric) FROM aggtest;
@@ -102,13 +108,20 @@ SELECT var_samp(b::numeric) FROM aggtest;
 -- SQL2003 binary aggregates
 SELECT regr_count(b, a) FROM aggtest;
 SELECT regr_sxx(b, a) FROM aggtest;
-SELECT regr_syy(b, a) FROM aggtest;
-SELECT regr_sxy(b, a) FROM aggtest;
-SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
-SELECT regr_r2(b, a) FROM aggtest;
-SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
-SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
-SELECT corr(b, a) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_syy(b, a)::numeric(20,10) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_sxy(b, a)::numeric(20,10) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_avgx(b, a), regr_avgy(b, a)::numeric(20,10) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_r2(b, a)::numeric(20,10) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT regr_slope(b, a)::numeric(20,10), regr_intercept(b, a)::numeric(20,10) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT covar_pop(b, a)::numeric(20,10), covar_samp(b, a)::numeric(20,10) FROM aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+SELECT corr(b, a)::numeric(20,10) FROM aggtest;
 
 SELECT count(four) AS cnt_1000 FROM onek;
 SELECT count(DISTINCT four) AS cnt_4 FROM onek;
@@ -329,7 +342,7 @@ explain (costs off)
 select max(100) from tenk1;
 
 -- try it on an inheritance tree
-create foreign table minmaxtest(f1 int) server sqlite_svr;;
+create foreign table minmaxtest(f1 int) server sqlite_svr;
 create table minmaxtest1() inherits (minmaxtest);
 create table minmaxtest2() inherits (minmaxtest);
 create table minmaxtest3() inherits (minmaxtest);
@@ -608,8 +621,10 @@ from generate_series(1,5) x,
 group by f1 order by f1;
 rollback;
 
-select percentile_cont(0.5) within group (order by b) from aggtest;
-select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+select (percentile_cont(0.5) within group (order by b))::numeric(20,10) from aggtest;
+-- Round the result to limited digits to avoid platform-specific results.
+select (percentile_cont(0.5) within group (order by b))::numeric(20,10), sum(b)::numeric(10,3) from aggtest;
 select percentile_cont(0.5) within group (order by thousand) from tenk1;
 select percentile_disc(0.5) within group (order by thousand) from tenk1;
 
@@ -618,7 +633,8 @@ delete from INT4_TBL;
 insert into INT4_TBL values (1),(1),(2),(2),(3),(3),(4);
 select rank(3) within group (order by f1) from INT4_TBL;
 select cume_dist(3) within group (order by f1) from INT4_TBL;
-select percent_rank(3) within group (order by f1) from INT4_TBL;
+-- Round the result to limited digits to avoid platform-specific results.
+select (percent_rank(3) within group (order by f1))::numeric(20,10) from INT4_TBL;
 select dense_rank(3) within group (order by f1) from INT4_TBL;
 rollback;
 
diff --git a/sql/extra/datetimes.data b/sql/extra/datetimes.data
new file mode 100644
index 0000000..0c062ef
--- /dev/null
+++ b/sql/extra/datetimes.data
@@ -0,0 +1,3 @@
+FirstDate	2020-05-12 11:45:31.414014+00	1589283931.41401
+SecondDate	2020-05-12 13:32:31.500274+00	1589290351.50027
+ThirdDate	2020-05-10 10:45:29+00	1589107529
\ No newline at end of file
diff --git a/sql/extra/float8.sql b/sql/extra/float8.sql
index 0e5bd5a..10bc526 100644
--- a/sql/extra/float8.sql
+++ b/sql/extra/float8.sql
@@ -263,4 +263,4 @@ RESET extra_float_digits;
 
 DROP FOREIGN TABLE FLOAT8_TBL;
 DROP SERVER sqlite_svr;
-DROP EXTENSION sqlite_fdw CASCADE;
\ No newline at end of file
+DROP EXTENSION sqlite_fdw CASCADE;
diff --git a/sql/extra/init_core.sql b/sql/extra/init_core.sql
index 105b198..b10226d 100644
--- a/sql/extra/init_core.sql
+++ b/sql/extra/init_core.sql
@@ -126,6 +126,12 @@ CREATE TABLE road (
 	thepath 	path
 );
 
+CREATE TABLE dates (
+	name			TEXT,
+	date_as_text	TEXT,
+	date_as_number	FLOAT8
+);
+
 .separator "\t"
 .import /tmp/onek.data onek
 .import /tmp/onek.data onek2
@@ -134,6 +140,7 @@ CREATE TABLE road (
 .import /tmp/student.data student
 .import /tmp/person.data person
 .import /tmp/streets.data road
+.import /tmp/datetimes.data dates
 
 INSERT INTO tenk2 SELECT * FROM tenk1;
 
diff --git a/sql/extra/int8.sql b/sql/extra/int8.sql
index f4d7cad..7daef26 100644
--- a/sql/extra/int8.sql
+++ b/sql/extra/int8.sql
@@ -12,9 +12,9 @@ CREATE FOREIGN TABLE INT8_TBL(
 
 INSERT INTO INT8_TBL VALUES('  123   ','  456');
 INSERT INTO INT8_TBL VALUES('123   ','4567890123456789');
+INSERT INTO INT8_TBL VALUES('+4567890123456789','-4567890123456789');
 INSERT INTO INT8_TBL VALUES('4567890123456789','123');
 INSERT INTO INT8_TBL VALUES(+4567890123456789,'4567890123456789');
-INSERT INTO INT8_TBL VALUES('+4567890123456789','-4567890123456789');
 
 -- bad inputs
 INSERT INTO INT8_TBL(q1) VALUES ('      ');
diff --git a/sql/extra/join.sql b/sql/extra/join.sql
index 2ef0c74..5d9f78a 100644
--- a/sql/extra/join.sql
+++ b/sql/extra/join.sql
@@ -36,8 +36,6 @@ CREATE FOREIGN TABLE tenk1 (
   string4   name
 ) SERVER sqlite_svr;
 
-ALTER TABLE tenk1 SET WITH OIDS;
-
 CREATE FOREIGN TABLE tenk2 (
   unique1   int4,
   unique2   int4,
@@ -458,17 +456,18 @@ where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
 --
 -- check a case where we formerly got confused by conflicting sort orders
 -- in redundant merge join path keys
+-- PS: Used ORDER BY to force SQLite and PG12 always order in the same way (NULLS FIRST/LAST default value for PG and Sqlite are different)
 --
 explain (costs off)
 select * from
   j1_tbl full join
   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl
-  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k ORDER BY j1_tbl.i, j2_tbl.k;
 
 select * from
   j1_tbl full join
   (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl
-  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
+  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k ORDER BY j1_tbl.i, j2_tbl.k;
 
 --
 -- a different check for handling of redundant sort keys in merge joins
diff --git a/sql/extra/limit.sql b/sql/extra/limit.sql
index db8501a..70b48d5 100644
--- a/sql/extra/limit.sql
+++ b/sql/extra/limit.sql
@@ -45,6 +45,29 @@ CREATE FOREIGN TABLE tenk1 (
 	string4		name
 ) SERVER sqlite_svr;
 
+CREATE TABLE parent_table (
+	unique1		int4 PRIMARY KEY,
+	unique2		int4,
+	two 		int4,
+	four		int4,
+	ten 		int4,
+	twenty		int4,
+	hundred		int4,
+	thousand	int4,
+	twothousand	int4,
+	fivethous	int4,
+	tenthous	int4,
+	odd			int4,
+	even		int4,
+	stringu1	name,
+	stringu2	name,
+	string4		name
+);
+
+CREATE FOREIGN table inherited_table ()
+INHERITS (parent_table)
+SERVER sqlite_svr options (table 'tenk1');
+
 SELECT ''::text AS two, unique1, unique2, stringu1
 		FROM onek WHERE unique1 > 50
 		ORDER BY unique1 LIMIT 2;
@@ -102,6 +125,30 @@ select unique1, unique2, nextval('testseq')
 select unique1, unique2, nextval('testseq')
   from tenk1 order by unique2 limit 10;
 
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 limit 10 offset 5;
+
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 limit 10 offset 5;
+
+select currval('testseq');
+
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 desc limit 10;
+
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 desc limit 10;
+
+
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 desc limit 10 offset 5;
+
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by unique2 desc limit 10 offset 5;
+
 select currval('testseq');
 
 explain (verbose, costs off)
@@ -111,6 +158,31 @@ select unique1, unique2, nextval('testseq')
 select unique1, unique2, nextval('testseq')
   from tenk1 order by tenthous limit 10;
 
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by tenthous limit 10 offset 5;
+
+select unique1, unique2, nextval('testseq')
+  from tenk1 order by tenthous limit 10 offset 5;
+
+select currval('testseq');
+
+-- test for limit and offset when querying table and foreign table inherited
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from parent_table order by tenthous limit 10;
+
+select unique1, unique2, nextval('testseq')
+  from parent_table order by tenthous limit 10;
+
+-- when querying regular tables with inherited tables, only limit is pushed-down when no offset is specified
+explain (verbose, costs off)
+select unique1, unique2, nextval('testseq')
+  from parent_table order by tenthous limit 10 offset 5;
+
+select unique1, unique2, nextval('testseq')
+  from parent_table order by tenthous limit 10 offset 5;
+
 select currval('testseq');
 
 explain (verbose, costs off)
@@ -137,6 +209,8 @@ select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2
 
 DROP FOREIGN TABLE onek;
 DROP FOREIGN TABLE int8_tbl;
+DROP FOREIGN TABLE inherited_table;
+DROP TABLE parent_table;
 DROP FOREIGN TABLE tenk1;
 DROP SERVER sqlite_svr;
 DROP EXTENSION sqlite_fdw CASCADE;
\ No newline at end of file
diff --git a/sql/extra/numeric.sql b/sql/extra/numeric.sql
index a84dc27..98e08ed 100644
--- a/sql/extra/numeric.sql
+++ b/sql/extra/numeric.sql
@@ -646,7 +646,7 @@ INSERT INTO ceil_floor_round VALUES ('9.4999999');
 INSERT INTO ceil_floor_round VALUES ('0.0');
 INSERT INTO ceil_floor_round VALUES ('0.0000001');
 INSERT INTO ceil_floor_round VALUES ('-0.000001');
-SELECT a, ceil(a), ceiling(a), floor(a), round(a) FROM ceil_floor_round;
+SELECT a, ceil(a), ceiling(a), floor(a), round(a) FROM ceil_floor_round ORDER BY a;
 
 -- normal operation
 CREATE FOREIGN TABLE width_bucket_test (
@@ -790,4 +790,4 @@ begin
 end;
 $d$;
 DROP SERVER sqlite_svr;
-DROP EXTENSION sqlite_fdw CASCADE;
\ No newline at end of file
+DROP EXTENSION sqlite_fdw CASCADE;
diff --git a/sql/extra/prepare.sql b/sql/extra/prepare.sql
index 6536c92..372becd 100644
--- a/sql/extra/prepare.sql
+++ b/sql/extra/prepare.sql
@@ -21,11 +21,10 @@ CREATE FOREIGN TABLE tenk1 (
 	even		int4,
 	stringu1	name,
 	stringu2	name,
-	string4		name
+	string4		name,
+    oid         oid
 ) SERVER sqlite_svr;
 
-ALTER TABLE tenk1 SET WITH OIDS;
-
 CREATE FOREIGN TABLE road (
 	name		text,
 	thepath 	path
diff --git a/sql/extra/select_having.sql b/sql/extra/select_having.sql
index 3493b52..07ee113 100644
--- a/sql/extra/select_having.sql
+++ b/sql/extra/select_having.sql
@@ -24,7 +24,7 @@ SELECT b, c FROM test_having
 
 -- HAVING is effectively equivalent to WHERE in this case
 SELECT b, c FROM test_having
-	GROUP BY b, c HAVING b = 3 ORDER BY b, c;
+	GROUP BY b, c HAVING b = 3 ORDER BY b, c collate "en_US.utf8";
 
 SELECT lower(c), count(c) FROM test_having
 	GROUP BY lower(c) HAVING count(*) > 2 OR min(a) = max(a)
@@ -32,7 +32,7 @@ SELECT lower(c), count(c) FROM test_having
 
 SELECT c, max(a) FROM test_having
 	GROUP BY c HAVING count(*) > 2 OR min(a) = max(a)
-	ORDER BY c;
+	ORDER BY c collate "en_US.utf8";
 
 -- test degenerate cases involving HAVING without GROUP BY
 -- Per SQL spec, these should generate 0 or 1 row, even without aggregates
diff --git a/sql/extra/timestamp.sql b/sql/extra/timestamp.sql
new file mode 100644
index 0000000..2b208da
--- /dev/null
+++ b/sql/extra/timestamp.sql
@@ -0,0 +1,57 @@
+--
+-- TIMESTAMP
+--
+CREATE EXTENSION sqlite_fdw;
+CREATE SERVER sqlite_svr FOREIGN DATA WRAPPER sqlite_fdw
+OPTIONS (database '/tmp/sqlitefdw_test_core.db');
+CREATE FOREIGN TABLE dates1 (
+	name varchar(20),
+	date_as_text timestamp without time zone,
+	date_as_number timestamp without time zone)
+SERVER sqlite_svr
+OPTIONS (table 'dates');
+
+CREATE FOREIGN TABLE dates2 (
+	name varchar(20),
+	date_as_text timestamp without time zone,
+	date_as_number double precision)
+SERVER sqlite_svr
+OPTIONS (table 'dates');
+
+-- Showing timestamp column from SQLite value as TEXT and as INTEGER/FLOAT has same value
+SELECT name,
+	to_char(date_as_text, 	'YYYY-MM-DD HH24:MI:SS.MS') as date_as_text, 
+	to_char(date_as_number, 'YYYY-MM-DD HH24:MI:SS.MS') as date_as_number
+FROM dates1;
+SELECT * FROM dates2;
+
+-- Comparing exact values showing same results even comparing to a text source sqlite column or numerical source sqlite column
+SELECT * FROM dates1
+WHERE date_as_text = to_timestamp('2020-05-10 10:45:29.000', 'YYYY-MM-DD HH24:MI:SS.MS');
+
+SELECT * FROM dates1
+WHERE date_as_number = to_timestamp('2020-05-10 10:45:29.000', 'YYYY-MM-DD HH24:MI:SS.MS');
+
+SELECT * FROM dates1
+WHERE date_as_text = to_timestamp('2020-05-10 10:45:29', 'YYYY-MM-DD HH24:MI:SS.MS');
+
+SELECT * FROM dates1
+WHERE date_as_number = to_timestamp('2020-05-10 10:45:29', 'YYYY-MM-DD HH24:MI:SS.MS');
+
+-- Comparing greater values showing same results even comparing to a text source sqlite column or numerical source sqlite column
+SELECT * FROM dates1
+WHERE date_as_text > to_timestamp('2020-05-10 10:45:29.000', 'YYYY-MM-DD HH24:MI:SS.MS');
+
+SELECT * FROM dates1
+WHERE date_as_number > to_timestamp('2020-05-10 10:45:29.000', 'YYYY-MM-DD HH24:MI:SS.MS');
+
+SELECT * FROM dates1
+WHERE date_as_text > to_timestamp('2020-05-10 10:45:29', 'YYYY-MM-DD HH24:MI:SS.MS');
+
+SELECT * FROM dates1
+WHERE date_as_number > to_timestamp('2020-05-10 10:45:29', 'YYYY-MM-DD HH24:MI:SS.MS');
+
+DROP FOREIGN TABLE dates1;
+DROP FOREIGN TABLE dates2;
+DROP SERVER sqlite_svr;
+DROP EXTENSION sqlite_fdw CASCADE;
diff --git a/sql/sqlite_fdw.sql b/sql/sqlite_fdw.sql
index 036ea68..7c21fd5 100644
--- a/sql/sqlite_fdw.sql
+++ b/sql/sqlite_fdw.sql
@@ -37,7 +37,7 @@ EXPLAIN (COSTS FALSE) SELECT * FROM department d, employee e WHERE d.department_
 EXPLAIN (COSTS FALSE) SELECT * FROM department d, employee e WHERE d.department_id IN (SELECT department_id FROM department) LIMIT 10;
 
 SELECT * FROM department d, employee e WHERE d.department_id = e.emp_dept_id LIMIT 10;
-SELECT * FROM department d, employee e WHERE d.department_id IN (SELECT department_id FROM department) LIMIT 10;
+SELECT * FROM department d, employee e WHERE d.department_id IN (SELECT department_id FROM department) ORDER BY d.department_id LIMIT 10;
 SELECT * FROM empdata;
 
 DELETE FROM employee WHERE emp_id = 10;
diff --git a/sqlite_fdw.c b/sqlite_fdw.c
index 817213a..d722256 100644
--- a/sqlite_fdw.c
+++ b/sqlite_fdw.c
@@ -201,7 +201,27 @@ static void create_cursor(ForeignScanState *node);
 static bool foreign_grouping_ok(PlannerInfo *root, RelOptInfo *grouped_rel);
 static void add_foreign_grouping_paths(PlannerInfo *root,
 									   RelOptInfo *input_rel,
-									   RelOptInfo *grouped_rel);
+									   RelOptInfo *grouped_rel
+#if (PG_VERSION_NUM >= 110000)
+									   ,GroupPathExtraData *extra
+#endif
+);
+static void add_foreign_ordered_paths(PlannerInfo *root,
+						  RelOptInfo *input_rel,
+						  RelOptInfo *ordered_rel);
+static void add_foreign_final_paths(PlannerInfo *root,
+						RelOptInfo *input_rel,
+						RelOptInfo *final_rel
+#if (PG_VERSION_NUM >= 120000)
+						,FinalPathExtraData *extra
+#endif
+);
+
+static bool all_baserels_are_foreign(PlannerInfo *root);
+
+static void add_paths_with_pathkeys_for_rel(PlannerInfo *root, RelOptInfo *rel, List *fdw_private);
+static List *get_useful_pathkeys_for_relation(PlannerInfo *root,
+								 RelOptInfo *rel);
 
 /*
  * Library load-time initialization, sets on_proc_exit() callback for
@@ -365,7 +385,144 @@ sqliteGetForeignRelSize(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntable
 						 quote_identifier(rte->eref->aliasname));
 }
 
+/*
+ * get_useful_pathkeys_for_relation
+ *		Determine which orderings of a relation might be useful.
+ *
+ * Getting data in sorted order can be useful either because the requested
+ * order matches the final output ordering for the overall query we're
+ * planning, or because it enables an efficient merge join.  Here, we try
+ * to figure out which pathkeys to consider.
+ */
+static List *
+get_useful_pathkeys_for_relation(PlannerInfo *root, RelOptInfo *rel)
+{
+	List	   *useful_pathkeys_list = NIL;
+	List	   *useful_eclass_list;
+	SqliteFdwRelationInfo *fpinfo = (SqliteFdwRelationInfo *) rel->fdw_private;
+	EquivalenceClass *query_ec = NULL;
+	ListCell   *lc;
+
+	/*
+	 * Pushing the query_pathkeys to the remote server is always worth
+	 * considering, because it might let us avoid a local sort.
+	 */
+	fpinfo->qp_is_pushdown_safe = false;
+	if (root->query_pathkeys)
+	{
+		bool		query_pathkeys_ok = true;
+
+		foreach(lc, root->query_pathkeys)
+		{
+			PathKey    *pathkey = (PathKey *) lfirst(lc);
+			EquivalenceClass *pathkey_ec = pathkey->pk_eclass;
+			Expr	   *em_expr;
+
+			/*
+			 * The planner and executor don't have any clever strategy for
+			 * taking data sorted by a prefix of the query's pathkeys and
+			 * getting it to be sorted by all of those pathkeys. We'll just
+			 * end up resorting the entire data set.  So, unless we can push
+			 * down all of the query pathkeys, forget it.
+			 *
+			 * is_foreign_expr would detect volatile expressions as well, but
+			 * checking ec_has_volatile here saves some cycles.
+			 */
+			if (pathkey_ec->ec_has_volatile ||
+				!(em_expr = find_em_expr_for_rel(pathkey_ec, rel)) ||
+				!sqlite_is_foreign_expr(root, rel, em_expr))
+			{
+				query_pathkeys_ok = false;
+				break;
+			}
+		}
+
+		if (query_pathkeys_ok)
+		{
+			useful_pathkeys_list = list_make1(list_copy(root->query_pathkeys));
+			fpinfo->qp_is_pushdown_safe = true;
+		}
+	}
+
+	return useful_pathkeys_list;
+}
+
+static void
+add_paths_with_pathkeys_for_rel(PlannerInfo *root, RelOptInfo *rel, List *fdw_private)
+{
+	List	   *useful_pathkeys_list = NIL; /* List of all pathkeys */
+	ListCell   *lc;
+	double 		rows;
+	Cost        startup_cost;
+	Cost        total_cost;
+
+	// Use small cost to avoid calculating real cost size in SQLite
+	rows = startup_cost = total_cost = 10;
+
+	useful_pathkeys_list = get_useful_pathkeys_for_relation(root, rel);
+
+	/* Create one path for each set of pathkeys we found above. */
+	foreach(lc, useful_pathkeys_list)
+	{
+		List	   *useful_pathkeys = lfirst(lc);
+
+		if (rel->reloptkind == RELOPT_BASEREL ||
+			rel->reloptkind == RELOPT_OTHER_MEMBER_REL)
+			add_path(rel, (Path *)
+					 create_foreignscan_path(root, rel,
+											 NULL,
+											 rows,
+											 startup_cost,
+											 total_cost,
+											 useful_pathkeys,
+#if (PG_VERSION_NUM >= 120000)
+											 rel->lateral_relids,
+#else
+											 NULL,	/* no outer rel either */
+#endif
+											 NULL,
+											 fdw_private));
+		else
+			elog(ERROR, "Join clauses not supported for Order..");
+	}
+}
+
+/*
+ * Check if any of the tables queried aren't foreign tables.
+ * We use this function to add limit pushdownm fallback to sqlite
+ * because if theres any non-foreign table, GetForeignUpperPath its not called from planner.c
+ */
+static bool
+all_baserels_are_foreign(PlannerInfo *root)
+{
+	bool		allTablesQueriedAreForeign = true;
+	ListCell	*l;
+
+	// If there is no append_rel_list, we assume we're only consulting a foreign table, so default value it's true and we dont need to do more.
+	foreach(l, root->append_rel_list)
+	{
+		AppendRelInfo *appinfo = lfirst_node(AppendRelInfo, l);
+		int				childRTindex;
+		RangeTblEntry	*childRTE;
+		RelOptInfo		*childrel;
+
+		/* Re-locate the child RTE and RelOptInfo */
+		childRTindex = appinfo->child_relid;
+		childRTE = root->simple_rte_array[childRTindex];
+		childrel = root->simple_rel_array[childRTindex];
 
+		if (!(IS_DUMMY_REL(childrel) || childRTE->inh))
+		{
+			if (!(childrel->rtekind == RTE_RELATION && childRTE->relkind == RELKIND_FOREIGN_TABLE))
+			{
+				allTablesQueriedAreForeign = false;
+				break;
+			}
+		}
+	}
+
+	return allTablesQueriedAreForeign;
+}
 
 /*
  * sqliteGetForeignPaths
@@ -376,11 +533,22 @@ sqliteGetForeignPaths(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid
 {
 	Cost		startup_cost = 10;
 	Cost		total_cost = baserel->rows + startup_cost;
+	List	   *fdw_private = NIL;
 
 	elog(DEBUG1, "sqlite_fdw : %s", __func__);
 	/* Estimate costs */
 	total_cost = baserel->rows;
 
+	/* XXX: We add fdw_private with has_limit: true if these three conditions are true because we need to be able to pushdown
+	limit in this case:
+	- Query has LIMIT
+	- Query don't have OFFSET because if we pusdown OFFSET and later, we re-applying offset with the "final result", and we would be "jumping/skipping" child results
+	and losing registries that we wanted to show.
+	- Some of the baserels are not a foreign table, so PostgreSQL is not calling GetForeignUpperPaths
+	 */
+	if (limit_needed(root->parse) && !root->parse->limitOffset && !all_baserels_are_foreign(root))
+		fdw_private = list_make2(makeInteger(false), makeInteger(true));
+
 	/* Create a ForeignPath node and add it as only possible path */
 	add_path(baserel, (Path *)
 			 create_foreignscan_path(root, baserel,
@@ -397,7 +565,10 @@ sqliteGetForeignPaths(PlannerInfo *root, RelOptInfo *baserel, Oid foreigntableid
 									 NULL,	/* no outer rel either */
 #endif
 									 NULL,	/* no extra plan */
-									 NULL));	/* no fdw_private data */
+									 fdw_private));
+
+	/* Add paths with pathkeys */
+	add_paths_with_pathkeys_for_rel(root, baserel, fdw_private);
 }
 
 /*
@@ -417,6 +588,8 @@ sqliteGetForeignPlan(
 	List	   *remote_conds = NIL;
 
 	StringInfoData sql;
+	bool	   has_final_sort = false;
+	bool	   has_limit = false;
 	List	   *retrieved_attrs;
 	ListCell   *lc;
 	List	   *fdw_recheck_quals = NIL;
@@ -424,6 +597,15 @@ sqliteGetForeignPlan(
 
 	elog(DEBUG1, "sqlite_fdw : %s", __func__);
 
+	/*
+	 * Get FDW private data created by sqliteGetForeignUpperPaths(), if any.
+	 */
+	if (best_path->fdw_private)
+	{
+		has_final_sort = intVal(list_nth(best_path->fdw_private, FdwPathPrivateHasFinalSort));
+		has_limit = intVal(list_nth(best_path->fdw_private, FdwPathPrivateHasLimit));
+	}
+
 	/*
 	 * Build the query string to be sent for execution, and identify
 	 * expressions to be sent as parameters.
@@ -566,7 +748,8 @@ sqliteGetForeignPlan(
 	initStringInfo(&sql);
 	sqliteDeparseSelectStmtForRel(&sql, root, baserel, fdw_scan_tlist,
 								  remote_exprs, best_path->path.pathkeys,
-								  false, &retrieved_attrs, &params_list);
+								  has_final_sort, has_limit, false,
+								  &retrieved_attrs, &params_list);
 
 	for_update = false;
 	if (root->parse->commandType == CMD_UPDATE ||
@@ -688,7 +871,6 @@ sqliteBeginForeignScan(ForeignScanState *node, int eflags)
 							 &festate->param_types);
 }
 
-
 static void
 make_tuple_from_result_row(sqlite3_stmt * stmt,
 						   TupleDesc tupleDescriptor,
@@ -1813,14 +1995,37 @@ sqliteGetForeignUpperPaths(PlannerInfo *root, UpperRelationKind stage,
 		return;
 
 	/* Ignore stages we don't support; and skip any duplicate calls. */
-	if (stage != UPPERREL_GROUP_AGG || output_rel->fdw_private)
+	if ((stage != UPPERREL_GROUP_AGG && stage != UPPERREL_ORDERED && stage != UPPERREL_FINAL) || output_rel->fdw_private)
 		return;
 
 	fpinfo = (SqliteFdwRelationInfo *) palloc0(sizeof(SqliteFdwRelationInfo));
 	fpinfo->pushdown_safe = false;
+	fpinfo->stage = stage;
 	output_rel->fdw_private = fpinfo;
 
-	add_foreign_grouping_paths(root, input_rel, output_rel);
+	switch (stage)
+	{
+		case UPPERREL_GROUP_AGG:
+			add_foreign_grouping_paths(root, input_rel, output_rel
+#if (PG_VERSION_NUM >= 110000)
+									   , (GroupPathExtraData *) extra
+#endif
+									   );
+			break;
+		case UPPERREL_ORDERED:
+			add_foreign_ordered_paths(root, input_rel, output_rel);
+			break;
+		case UPPERREL_FINAL:
+			add_foreign_final_paths(root, input_rel, output_rel
+#if (PG_VERSION_NUM >= 120000)
+									   , (FinalPathExtraData *) extra
+#endif
+									   );
+			break;
+		default:
+			elog(ERROR, "unexpected upper relation: %d", (int) stage);
+			break;
+	}
 }
 
 /*
@@ -1832,7 +2037,11 @@ sqliteGetForeignUpperPaths(PlannerInfo *root, UpperRelationKind stage,
  */
 static void
 add_foreign_grouping_paths(PlannerInfo *root, RelOptInfo *input_rel,
-						   RelOptInfo *grouped_rel)
+						   RelOptInfo *grouped_rel
+#if (PG_VERSION_NUM >= 110000)
+						   , GroupPathExtraData *extra
+#endif
+						   )
 {
 	Query	   *parse = root->parse;
 	SqliteFdwRelationInfo *ifpinfo = input_rel->fdw_private;
@@ -1906,6 +2115,334 @@ add_foreign_grouping_paths(PlannerInfo *root, RelOptInfo *input_rel,
 }
 
 
+/*
+ * add_foreign_ordered_paths
+ *		Add foreign paths for performing the final sort remotely.
+ *
+ * Given input_rel contains the source-data Paths.  The paths are added to the
+ * given ordered_rel.
+ */
+static void
+add_foreign_ordered_paths(PlannerInfo *root, RelOptInfo *input_rel,
+						  RelOptInfo *ordered_rel)
+{
+	Query	   *parse = root->parse;
+	SqliteFdwRelationInfo *ifpinfo = input_rel->fdw_private;
+	SqliteFdwRelationInfo *fpinfo = ordered_rel->fdw_private;
+	double		rows;
+	int			width;
+	Cost		startup_cost;
+	Cost		total_cost;
+	List	   *fdw_private;
+	ForeignPath *ordered_path;
+	ListCell   *lc;
+
+	/* Shouldn't get here unless the query has ORDER BY */
+	Assert(parse->sortClause);
+
+#if (PG_VERSION_NUM >= 100000)
+	/* We don't support cases where there are any SRFs in the targetlist */
+	if (parse->hasTargetSRFs)
+		return;
+#else
+	/* We don't support cases where there are any SRFs in the targetlist (PG Version >10) */
+	if (expression_returns_set((Node *) parse->targetList))
+		return;
+#endif
+
+	/* Save the input_rel as outerrel in fpinfo */
+	fpinfo->outerrel = input_rel;
+
+	/*
+	 * Copy foreign table, foreign server, user mapping, FDW options etc.
+	 * details from the input relation's fpinfo.
+	 */
+	fpinfo->table = ifpinfo->table;
+	fpinfo->server = ifpinfo->server;
+
+	fpinfo->shippable_extensions = ifpinfo->shippable_extensions;
+
+
+	/*
+	 * If the input_rel is a base or join relation, we would already have
+	 * considered pushing down the final sort to the remote server when
+	 * creating pre-sorted foreign paths for that relation, because the
+	 * query_pathkeys is set to the root->sort_pathkeys in that case (see
+	 * standard_qp_callback()).
+	 */
+	if (input_rel->reloptkind == RELOPT_BASEREL ||
+		input_rel->reloptkind == RELOPT_JOINREL)
+	{
+		Assert(root->query_pathkeys == root->sort_pathkeys);
+
+		/* Safe to push down if the query_pathkeys is safe to push down */
+		fpinfo->pushdown_safe = ifpinfo->qp_is_pushdown_safe;
+
+		return;
+	}
+
+	/* The input_rel should be a grouping relation */
+	Assert(input_rel->reloptkind == RELOPT_UPPER_REL &&
+		   ifpinfo->stage == UPPERREL_GROUP_AGG);
+
+	/*
+	 * We try to create a path below by extending a simple foreign path for
+	 * the underlying grouping relation to perform the final sort remotely,
+	 * which is stored into the fdw_private list of the resulting path.
+	 */
+
+	/* Assess if it is safe to push down the final sort */
+	foreach(lc, root->sort_pathkeys)
+	{
+		PathKey    *pathkey = (PathKey *) lfirst(lc);
+		EquivalenceClass *pathkey_ec = pathkey->pk_eclass;
+		Expr	   *sort_expr;
+		RelOptInfo* fallback_rel = (input_rel->reloptkind == RELOPT_UPPER_REL) ?
+			ifpinfo->outerrel : input_rel;
+
+		/*
+		 * is_foreign_expr would detect volatile expressions as well, but
+		 * checking ec_has_volatile here saves some cycles.
+		 */
+		if (pathkey_ec->ec_has_volatile)
+			return;
+
+		/* Get the sort expression for the pathkey_ec */
+		sort_expr = find_em_expr_for_input_target(root,
+												  pathkey_ec,
+												  input_rel->reltarget,
+												  fallback_rel);
+
+		/* If it's unsafe to remote, we cannot push down the final sort */
+		if (!sqlite_is_foreign_expr(root, input_rel, sort_expr))
+			return;
+	}
+
+	/* Safe to push down */
+	fpinfo->pushdown_safe = true;
+
+	/* Use small cost to push down aggregate always */
+	rows = width = startup_cost = total_cost = 1;
+	/* Now update this information in the fpinfo */
+	fpinfo->rows = rows;
+	fpinfo->width = width;
+	fpinfo->startup_cost = startup_cost;
+	fpinfo->total_cost = total_cost;
+
+	/*
+	 * Build the fdw_private list that will be used by sqliteGetForeignPlan.
+	 * Items in the list must match order in enum FdwPathPrivateIndex.
+	 */
+	fdw_private = list_make2(makeInteger(true), makeInteger(false));
+
+#if (PG_VERSION_NUM >= 120000)
+	/* Create foreign ordering path */
+	ordered_path = create_foreign_upper_path(root,
+											 input_rel,
+											 root->upper_targets[UPPERREL_ORDERED],
+											 rows,
+											 startup_cost,
+											 total_cost,
+											 root->sort_pathkeys,
+											 NULL,	/* no extra plan */
+											 fdw_private);
+#else
+	// XXX: We use root->upper_targets[UPERREL_FINAL] because until PG12, upper_targets[UPPERREL_ORDERED] is not filled.
+	// Anyways, in PG12 root->upper_targets[UPPERREL_FINAL] and root->upper_targets[UPPERREL_ORDERED] have the same value.
+	// More info: backend/optimizer/plan/planner.c (Line 2189)
+	/* Create foreign ordering path */
+	ordered_path = create_foreignscan_path(root,
+											 input_rel,
+											 root->upper_targets[UPPERREL_FINAL],
+											 rows,
+											 startup_cost,
+											 total_cost,
+											 root->sort_pathkeys,
+											 NULL,
+											 NULL,	/* no extra plan */
+											 fdw_private);
+#endif
+
+	/* and add it to the ordered_rel */
+	add_path(ordered_rel, (Path *) ordered_path);
+}
+
+/*
+ * add_foreign_final_paths
+ *		Add foreign paths for performing the final processing remotely.
+ *
+ * Given input_rel contains the source-data Paths.  The paths are added to the
+ * given final_rel.
+ */
+static void
+add_foreign_final_paths(PlannerInfo *root, RelOptInfo *input_rel,
+						RelOptInfo *final_rel
+#if (PG_VERSION_NUM >= 120000)
+						, FinalPathExtraData *extra
+#endif
+)
+{
+	Query	   *parse = root->parse;
+	SqliteFdwRelationInfo *ifpinfo = (SqliteFdwRelationInfo *) input_rel->fdw_private;
+	SqliteFdwRelationInfo *fpinfo = (SqliteFdwRelationInfo *) final_rel->fdw_private;
+	bool		has_final_sort = false;
+	List	   *pathkeys = NIL;
+	double		rows;
+	int			width;
+	Cost		startup_cost;
+	Cost		total_cost;
+	List	   *fdw_private;
+	ForeignPath *final_path;
+	bool 		has_limit = limit_needed(parse);
+
+	/*
+	 * Currently, we only support this for SELECT commands
+	 */
+	if (parse->commandType != CMD_SELECT)
+		return;
+
+	/*
+	 * No work if there is FOR UPDATE/SHARE clause and if there is no need
+	 * to add a LIMIT node. We DONT support FOR UPDATE pushdown because SQLITE has no implemented yet,
+	 * that's why we dont do nothing.
+	 */
+	if (parse->rowMarks
+#if (PG_VERSION_NUM >= 120000)
+			|| !extra->limit_needed
+#else
+			|| !has_limit
+#endif
+	   )
+		return;
+
+#if (PG_VERSION_NUM >= 100000)
+	/* We don't support cases where there are any SRFs in the targetlist */
+	if (parse->hasTargetSRFs)
+		return;
+#else
+	/* We don't support cases where there are any SRFs in the targetlist (PG Version >10) */
+	if (expression_returns_set((Node *) parse->targetList))
+		return;
+#endif
+
+	/* Save the input_rel as outerrel in fpinfo */
+	fpinfo->outerrel = input_rel;
+
+	/*
+	 * Copy foreign table, foreign server, user mapping, FDW options etc.
+	 * details from the input relation's fpinfo.
+	 */
+	fpinfo->table = ifpinfo->table;
+	fpinfo->server = ifpinfo->server;
+
+	fpinfo->shippable_extensions = ifpinfo->shippable_extensions;
+
+#if (PG_VERSION_NUM >= 120000)
+	Assert(extra->limit_needed);
+#else
+	Assert(has_limit);
+#endif
+
+	/*
+	 * If the input_rel is an ordered relation, replace the input_rel with its
+	 * input relation
+	 */
+	if (input_rel->reloptkind == RELOPT_UPPER_REL &&
+		ifpinfo->stage == UPPERREL_ORDERED)
+	{
+		input_rel = ifpinfo->outerrel;
+		ifpinfo = (SqliteFdwRelationInfo *) input_rel->fdw_private;
+		has_final_sort = true;
+		pathkeys = root->sort_pathkeys;
+	}
+
+	/* The input_rel should be a base, join, or grouping relation */
+	Assert(input_rel->reloptkind == RELOPT_BASEREL ||
+		   input_rel->reloptkind == RELOPT_JOINREL ||
+		   (input_rel->reloptkind == RELOPT_UPPER_REL &&
+			ifpinfo->stage == UPPERREL_GROUP_AGG));
+
+	/*
+	 * We try to create a path below by extending a simple foreign path for
+	 * the underlying base, join, or grouping relation to perform the final
+	 * sort (if has_final_sort) and the LIMIT restriction remotely, which is
+	 * stored into the fdw_private list of the resulting path.  (We
+	 * re-estimate the costs of sorting the underlying relation, if
+	 * has_final_sort.)
+	 */
+
+	/*
+	 * Assess if it is safe to push down the LIMIT and OFFSET to the remote
+	 * server
+	 */
+
+	/*
+	 * If the underlying relation has any local conditions, the LIMIT/OFFSET
+	 * cannot be pushed down.
+	 */
+	if (ifpinfo->local_conds)
+		return;
+
+	/*
+	 * Also, the LIMIT/OFFSET cannot be pushed down, if their expressions are
+	 * not safe to remote.
+	 */
+	if (!sqlite_is_foreign_expr(root, input_rel, (Expr *) parse->limitOffset) ||
+		!sqlite_is_foreign_expr(root, input_rel, (Expr *) parse->limitCount))
+		return;
+
+	/* Safe to push down */
+	fpinfo->pushdown_safe = true;
+
+	/* Use small cost to push down limit always */
+	rows = width = startup_cost = total_cost = 1;
+	/* Now update this information in the fpinfo */
+	fpinfo->rows = rows;
+	fpinfo->width = width;
+	fpinfo->startup_cost = startup_cost;
+	fpinfo->total_cost = total_cost;
+
+	/*
+	 * Build the fdw_private list that will be used by sqliteGetForeignPlan.
+	 * Items in the list must match order in enum FdwPathPrivateIndex.
+	 */
+	fdw_private = list_make2(makeInteger(has_final_sort),
+#if (PG_VERSION_NUM >= 120000)
+		makeInteger(extra->limit_needed));
+#else
+		makeInteger(has_limit));
+#endif
+
+	/*
+	 * Create foreign final path; this gets rid of a no-longer-needed outer
+	 * plan (if any), which makes the EXPLAIN output look cleaner
+	 */
+#if (PG_VERSION_NUM >= 120000)
+	final_path = create_foreign_upper_path(root,
+										   input_rel,
+										   root->upper_targets[UPPERREL_FINAL],
+										   rows,
+										   startup_cost,
+										   total_cost,
+										   pathkeys,
+										   NULL,	/* no extra plan */
+										   fdw_private);
+#else
+	final_path = create_foreignscan_path(root,
+										   input_rel,
+										   root->upper_targets[UPPERREL_FINAL],
+										   rows,
+										   startup_cost,
+										   total_cost,
+										   pathkeys,
+										   NULL, 	/* no required_outer */
+										   NULL,	/* no extra plan */
+										   fdw_private);
+#endif
+	/* and add it to the final_rel */
+	add_path(final_rel, (Path *) final_path);
+}
+
 static int
 get_estimate(Oid foreigntableid)
 {
@@ -2204,3 +2741,104 @@ create_cursor(ForeignScanState *node)
 	/* Mark the cursor as created, and show no tuples have been retrieved */
 	festate->cursor_exists = true;
 }
+
+/*
+ * Find an equivalence class member expression, all of whose Vars, come from
+ * the indicated relation.
+ */
+Expr *
+find_em_expr_for_rel(EquivalenceClass *ec, RelOptInfo *rel)
+{
+	ListCell   *lc_em;
+
+	foreach(lc_em, ec->ec_members)
+	{
+		EquivalenceMember *em = lfirst(lc_em);
+
+		if (bms_is_subset(em->em_relids, rel->relids) &&
+			!bms_is_empty(em->em_relids))
+		{
+			/*
+			 * If there is more than one equivalence member whose Vars are
+			 * taken entirely from this relation, we'll be content to choose
+			 * any one of those.
+			 */
+			return em->em_expr;
+		}
+	}
+
+	/* We didn't find any suitable equivalence class expression */
+	return NULL;
+}
+
+/*
+ * Find an equivalence class member expression to be computed as a sort column
+ * in the given target.
+ */
+Expr *
+find_em_expr_for_input_target(PlannerInfo *root,
+							  EquivalenceClass *ec,
+							  PathTarget *target,
+							  RelOptInfo *fallbackRel)
+{
+	ListCell   *lc1;
+	int			i;
+
+	i = 0;
+	foreach(lc1, target->exprs)
+	{
+		Expr	   *expr = (Expr *) lfirst(lc1);
+		Index		sgref = get_pathtarget_sortgroupref(target, i);
+		ListCell   *lc2;
+
+		/* Ignore non-sort expressions */
+		if (sgref == 0 ||
+			get_sortgroupref_clause_noerr(sgref,
+										  root->parse->sortClause) == NULL)
+		{
+			i++;
+			continue;
+		}
+
+		/* We ignore binary-compatible relabeling on both ends */
+		while (expr && IsA(expr, RelabelType))
+			expr = ((RelabelType *) expr)->arg;
+
+		/* Locate an EquivalenceClass member matching this expr, if any */
+		foreach(lc2, ec->ec_members)
+		{
+			EquivalenceMember *em = (EquivalenceMember *) lfirst(lc2);
+			Expr	   *em_expr;
+
+			/* Don't match constants */
+			if (em->em_is_const)
+				continue;
+
+			/* Ignore child members */
+			if (em->em_is_child)
+				continue;
+
+			/* Match if same expression (after stripping relabel) */
+			em_expr = em->em_expr;
+			while (em_expr && IsA(em_expr, RelabelType))
+				em_expr = ((RelabelType *) em_expr)->arg;
+
+			if (equal(em_expr, expr))
+				return em->em_expr;
+		}
+
+		i++;
+	}
+
+	Expr	   *fallback_expr;
+
+	// XXX: We add this method as fallback in versions prior to PG11/12 because target->sortgrouprefs its not filled and
+	// this function always fails because cannot find sort expression.
+	fallback_expr = find_em_expr_for_rel(ec, fallbackRel);
+
+	if (fallback_expr)
+		return fallback_expr;
+
+	elog(ERROR, "could not find pathkey item to sort");
+	return NULL;				/* keep compiler quiet */
+}
diff --git a/sqlite_fdw.h b/sqlite_fdw.h
index 0dade55..f7ed998 100644
--- a/sqlite_fdw.h
+++ b/sqlite_fdw.h
@@ -124,12 +124,19 @@ typedef struct SqliteFdwRelationInfo
 	List	   *shippable_extensions;	/* OIDs of whitelisted extensions */
 	/* Bitmap of attr numbers we need to fetch from the remote server. */
 	Bitmapset  *attrs_used;
+
+	/* True means that the query_pathkeys is safe to push down */
+	bool		qp_is_pushdown_safe;
+
 	/* Join information */
 	RelOptInfo *outerrel;
 	RelOptInfo *innerrel;
 	JoinType	jointype;
 	List	   *joinclauses;
 
+	/* Upper relation information */
+	UpperRelationKind stage;
+
 	/* Cached catalog information. */
 	ForeignTable *table;
 	ForeignServer *server;
@@ -145,11 +152,34 @@ typedef struct SqliteFdwRelationInfo
 	List	   *grouped_tlist;
 }			SqliteFdwRelationInfo;
 
+/*
+ * This enum describes what's kept in the fdw_private list for a ForeignPath.
+ * We store:
+ *
+ * 1) Boolean flag showing if the remote query has the final sort
+ * 2) Boolean flag showing if the remote query has the LIMIT clause
+ */
+enum FdwPathPrivateIndex
+{
+	/* has-final-sort flag (as an integer Value node) */
+	FdwPathPrivateHasFinalSort,
+	/* has-limit flag (as an integer Value node) */
+	FdwPathPrivateHasLimit
+};
 
 extern bool sqlite_is_foreign_expr(PlannerInfo *root,
 								   RelOptInfo *baserel,
 								   Expr *expr);
 
+extern Expr *find_em_expr_for_rel(EquivalenceClass *ec, RelOptInfo *rel);
+extern Expr *find_em_expr_for_input_target(PlannerInfo *root,
+							  EquivalenceClass *ec,
+							  PathTarget *target,
+							  RelOptInfo *fallbackRel);
+
+/* in postgres_fdw.c */
+extern int	set_transmission_modes(void);
+extern void reset_transmission_modes(int nestlevel);
 
 /* option.c headers */
 extern sqlite_opt * sqlite_get_options(Oid foreigntableid);
@@ -157,8 +187,8 @@ extern sqlite_opt * sqlite_get_options(Oid foreigntableid);
 /* depare.c headers */
 extern void sqliteDeparseSelectStmtForRel(StringInfo buf, PlannerInfo *root, RelOptInfo *rel,
 										  List *tlist, List *remote_conds, List *pathkeys,
-										  bool is_subquery, List **retrieved_attrs,
-										  List **params_list);
+										  bool has_final_sort, bool has_limit, bool is_subquery,
+										  List **retrieved_attrs, List **params_list);
 extern void sqlite_deparse_insert(StringInfo buf, PlannerInfo *root, Index rtindex, Relation rel, List *targetAttrs);
 extern void sqlite_deparse_update(StringInfo buf, PlannerInfo *root, Index rtindex, Relation rel, List *targetAttrs, List *attname);
 extern void sqlite_deparse_delete(StringInfo buf, PlannerInfo *root, Index rtindex, Relation rel, List *name);
diff --git a/sqlite_query.c b/sqlite_query.c
index fbd94c3..ac288b5 100644
--- a/sqlite_query.c
+++ b/sqlite_query.c
@@ -130,7 +130,6 @@ sqlite_convert_to_pg(Oid pgtyp, int pgtypmod, sqlite3_stmt * stmt, int attnum)
 				return Int64GetDatum(value);
 			}
 		case FLOAT4OID:
-
 			{
 				double		value = sqlite3_column_double(stmt, attnum);
 
@@ -144,6 +143,25 @@ sqlite_convert_to_pg(Oid pgtyp, int pgtypmod, sqlite3_stmt * stmt, int attnum)
 				return Float8GetDatum((float8) value);
 				break;
 			}
+		case TIMESTAMPOID:
+			{
+				// We add this conversion to allow add INTEGER/FLOAT SQLite Columns be added as TimeStamp in PostgreSQL.
+				// We just calling PostgreSQL function "to_timestamp(double value)"" to convert each registry returned
+				// from INT/FLOAT value to TimeStamp string, so PosgtreSQL can handle/show without problems.
+				// If it's a TEXT SQLite column...we let them to the "regular" process because its already implemented and
+				// working properly.
+				int sqlitetype = sqlite3_column_type(stmt, attnum);
+				if (sqlitetype == SQLITE_INTEGER || sqlitetype == SQLITE_FLOAT)
+				{
+						double value = sqlite3_column_double(stmt, attnum);
+						return DirectFunctionCall1(float8_timestamptz, Float8GetDatum((float8) value));
+				}
+				else
+				{
+						valueDatum = CStringGetDatum((char *) sqlite3_column_text(stmt, attnum));
+				}
+				break;
+			}
 		default:
 			valueDatum = CStringGetDatum((char *) sqlite3_column_text(stmt, attnum));
 	}
diff --git a/test_extra.sh b/test_extra.sh
index 0209130..4adc95b 100644
--- a/test_extra.sh
+++ b/test_extra.sh
@@ -5,7 +5,7 @@ cp -a sql/extra/*.data /tmp/
 sqlite3 /tmp/sqlitefdw_test_post.db < sql/extra/init_post.sql
 sqlite3 /tmp/sqlitefdw_test_core.db < sql/extra/init_core.sql
 
-sed -i 's/REGRESS =.*/REGRESS = extra\/sqlite_fdw_post extra\/float4 extra\/float8 extra\/int4 extra\/int8 extra\/numeric extra\/join extra\/limit extra\/aggregates extra\/prepare extra\/select_having extra\/select extra\/insert extra\/update /' Makefile
+sed -i 's/REGRESS =.*/REGRESS = extra\/sqlite_fdw_post extra\/float4 extra\/float8 extra\/int4 extra\/int8 extra\/numeric extra\/join extra\/limit extra\/aggregates extra\/prepare extra\/select_having extra\/select extra\/insert extra\/update extra\/timestamp /' Makefile
 
 make clean
 make
